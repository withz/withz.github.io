<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"withz.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="…">
<meta property="og:type" content="article">
<meta property="og:title" content="Python">
<meta property="og:url" content="https://withz.github.io/2020/02/09/Python/Python/index.html">
<meta property="og:site_name" content="Withz">
<meta property="og:description" content="…">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-02-09T04:04:06.000Z">
<meta property="article:modified_time" content="2024-06-07T02:52:59.328Z">
<meta property="article:author" content="Peng">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://withz.github.io/2020/02/09/Python/Python/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://withz.github.io/2020/02/09/Python/Python/","path":"2020/02/09/Python/Python/","title":"Python"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Python | Withz</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Withz</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">64</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">51</span></a></li><li class="menu-item menu-item-tools"><a href="/tools/" rel="section"><i class="fa fa-flask fa-fw"></i>工具</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">数字型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.2.</span> <span class="nav-text">原始格式化字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%BC%BA%E5%9E%8B%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.3.</span> <span class="nav-text">增强型格式化字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#f-string"><span class="nav-number">1.2.4.</span> <span class="nav-text">f-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unicode-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.5.</span> <span class="nav-text">Unicode 字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8"><span class="nav-number">1.3.</span> <span class="nav-text">列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%BB%84"><span class="nav-number">1.4.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.5.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E5%85%B8"><span class="nav-number">1.6.</span> <span class="nav-text">字典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.7.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.8.</span> <span class="nav-text">类型注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.</span> <span class="nav-text">内置函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.10.</span> <span class="nav-text">查看类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.1.</span> <span class="nav-text">for 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">2.2.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%AE%9A%E9%95%BF%E4%BC%A0%E5%8F%82"><span class="nav-number">2.3.</span> <span class="nav-text">不定长传参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.</span> <span class="nav-text">匿名函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">2.5.</span> <span class="nav-text">强制位置参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.6.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E6%A0%88"><span class="nav-number">2.6.1.</span> <span class="nav-text">堆栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">2.6.2.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">2.6.3.</span> <span class="nav-text">优先队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="nav-number">2.6.4.</span> <span class="nav-text">列表推导式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85"><span class="nav-number">2.7.</span> <span class="nav-text">模块与包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">2.8.</span> <span class="nav-text">读写文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OS-%E6%A8%A1%E5%9D%97"><span class="nav-number">2.9.</span> <span class="nav-text">OS 模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%96%AD%E8%A8%80"><span class="nav-number">2.10.</span> <span class="nav-text">异常与断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.11.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-number">2.12.</span> <span class="nav-text">标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shutil"><span class="nav-number">2.12.1.</span> <span class="nav-text">shutil</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#blog"><span class="nav-number">2.12.2.</span> <span class="nav-text">blog</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sys"><span class="nav-number">2.12.3.</span> <span class="nav-text">sys</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#re"><span class="nav-number">2.12.4.</span> <span class="nav-text">re</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#datetime"><span class="nav-number">2.12.5.</span> <span class="nav-text">datetime</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"><span class="nav-number">2.12.6.</span> <span class="nav-text">数据压缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="nav-number">2.12.7.</span> <span class="nav-text">计时器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">2.12.8.</span> <span class="nav-text">测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">4.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP"><span class="nav-number">4.1.</span> <span class="nav-text">HTTP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket"><span class="nav-number">4.2.</span> <span class="nav-text">Socket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uWSGI"><span class="nav-number">4.3.</span> <span class="nav-text">uWSGI</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#threading-%E6%A8%A1%E5%9D%97"><span class="nav-number">5.1.</span> <span class="nav-text">threading 模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multiprocessing-%E6%A8%A1%E5%9D%97"><span class="nav-number">5.2.</span> <span class="nav-text">multiprocessing 模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ctypes"><span class="nav-number">5.3.</span> <span class="nav-text">ctypes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.4.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-1"><span class="nav-number">5.5.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-number">5.6.</span> <span class="nav-text">生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">5.7.</span> <span class="nav-text">协程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XML-%E4%B8%8E-JSON"><span class="nav-number">6.</span> <span class="nav-text">XML 与 JSON</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XML"><span class="nav-number">6.1.</span> <span class="nav-text">XML</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Json"><span class="nav-number">6.2.</span> <span class="nav-text">Json</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-%E6%8A%80%E5%B7%A7"><span class="nav-number">7.</span> <span class="nav-text">Python 技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">7.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-1"><span class="nav-number">7.2.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6"><span class="nav-number">7.3.</span> <span class="nav-text">文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1-1"><span class="nav-number">7.4.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">7.5.</span> <span class="nav-text">函数装饰器</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Peng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://withz.github.io/2020/02/09/Python/Python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Withz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Python | Withz">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-09 12:04:06" itemprop="dateCreated datePublished" datetime="2020-02-09T12:04:06+08:00">2020-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-07 10:52:59" itemprop="dateModified" datetime="2024-06-07T10:52:59+08:00">2024-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>…</p>
<span id="more"></span>


<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h3><p>数字型包括：</p>
<ul>
<li>int：20</li>
<li>float：3.3</li>
<li>bool：True（True &#x3D; 1, False &#x3D; 0）</li>
<li>complex：4+2j, complex(4, 2)</li>
</ul>
<p>运算方式有：加(<code>+</code>)，减(<code>-</code>)，乘(<code>*</code>)，除-浮点(<code>/</code>)，除-整数(<code>//</code>)，取余(<code>%</code>)，乘方(<code>**</code>)</p>
<p>常用方法：</p>
<ul>
<li>range(n)：产生一个从0到n的序列。</li>
<li>range(m, n)：产生一个从m到n的序列。</li>
<li>sum()：对列表的所有元素求和</li>
<li>all()：判断列表中所有元素是否都是True</li>
<li>any()：判断列表中是否包含True</li>
</ul>
<p>运算方法：</p>
<ul>
<li>abs()</li>
<li>max()：参数可以为序列。</li>
<li>min()：参数可以为序列。</li>
<li>pow()：乘幂运算。</li>
<li>round()：四舍五入，可以指定小数点后的位数。</li>
<li>math.ceil()：向上取整。</li>
<li>math.floor()：向下取整。</li>
<li>math.exp()</li>
<li>math.fabs()</li>
<li>math.log()</li>
<li>math.log10()</li>
<li>math.modf()：返回小数部分和整数部分（元组，先小数，后整数）。</li>
<li>math.sqrt()</li>
<li>math.pi：内置常量，PI</li>
<li>math.e：内置常量，E</li>
</ul>
<p>随机函数：</p>
<ul>
<li>random.choice()：从给定的序列中随机选择一个元素。</li>
<li>random.randrange([start,] stop [, step])：在指定范围内按照基数底层的集合中获取一个随机数。基数默认为1。</li>
<li>random.random()：生成一个0到1之间的实数。</li>
<li>random.seed()：改变种子生成器。</li>
<li>random.shuffle()：将给定的序列随机排列。</li>
<li>random.uniform(x, y)：生成一个x到y之间的实数。</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>可以使用<code>&#39;inline&#39;</code>、<code>&quot;inline&quot;</code>、<code>&#39;&#39;&#39;multi lines&#39;&#39;&#39;</code>方式。 可以使用转义字符。 索引从前面开始为<code>0</code>；从后面开始为<code>-1</code>。 字符串只读，不能修改某一个字符。</p>
<p>运算方式有（设<code>str_a=&quot;123456789&quot;</code>）：</p>
<ul>
<li>加(<code>str_a + str_b</code>)：字符串拼接。</li>
<li>乘(<code>str_a * 2</code>)：字符串重复。</li>
<li>切片(<code>str_a[0:-1]</code>, <code>str_a[3:]</code>)：返回字串”12345678”，”456789”，遵循左闭右开。</li>
<li>禁用转义字符(<code>r&#39;\n&#39;</code>)：返回”\n”，R作用一以。</li>
<li>in：查看是否在其中。</li>
<li>not in</li>
<li>%：格式字符串</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
<th>字符</th>
<th>描述</th>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\</code></td>
<td>续行</td>
<td><code>\\</code></td>
<td>反斜线</td>
<td><code>\&#39;</code></td>
<td>单引号</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号</td>
<td><code>\a</code></td>
<td>响铃</td>
<td><code>\b</code></td>
<td>退格</td>
</tr>
<tr>
<td><code>\0</code></td>
<td>空</td>
<td><code>\n</code></td>
<td>换行</td>
<td><code>\v</code></td>
<td>纵向制表符</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车</td>
<td><code>\f</code></td>
<td>换页</td>
<td><code>\t</code></td>
<td>横向制表符</td>
</tr>
<tr>
<td><code>\oYY</code></td>
<td>八进制</td>
<td><code>\xYY</code></td>
<td>十六进制</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>join()：连接字符串</li>
<li>split()：分隔字符串，返回列表</li>
<li>count(s)：返回子串s出现次数</li>
<li>len()：返回字符串长度</li>
<li>strip()：去掉两边空格</li>
<li>find()：查找子串位置，未找到返回 -1</li>
<li>replace(old, new)：替换子串</li>
<li>bytes.decode(encoding&#x3D;’UTF-8’,errors&#x3D;’strict’)：解码为字符串</li>
<li>encode(encoding&#x3D;’UTF-8’,errors&#x3D;’strict’)：编码为二进制数据</li>
<li>ljust(width, fillchar)：左对齐，返回填充后的字符串</li>
<li>rstrip(width, fillchar)：右对齐，返回填充后的字符串</li>
<li>center(width, fillchar)：居中对齐，返回填充后的字符串</li>
</ul>
<h4 id="原始格式化字符串"><a href="#原始格式化字符串" class="headerlink" title="原始格式化字符串"></a>原始格式化字符串</h4><p>原始格式化字符串：</p>
<ul>
<li>%c：字符</li>
<li>%s：字符串</li>
<li>%d：整数</li>
<li>%u：无符号整数</li>
<li>%o：无符号八进制</li>
<li>%x：无符号十六进制</li>
<li>%X：无符号十六进制（大写）</li>
<li>%f：浮点，可以指定小数点后位数</li>
<li>%e：科学计数法</li>
<li>%E：科学计数法</li>
<li>%g：作用同%f%e</li>
<li>%G：作用同%f%E</li>
<li>%p：变量地址</li>
</ul>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;%s use python %f&quot; % (&#x27;User&#x27;, 3.7)</span><br></pre></td></tr></table></figure>

<p>辅助指令：</p>
<ul>
<li><code>*</code>：定义宽度或小数点精度</li>
<li><code>-</code>：左对齐</li>
<li><code>+</code>：在正数前面显示加号</li>
<li><code>&lt;sp&gt;</code>：在正数前面显示空格</li>
<li><code>#</code>：在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</li>
<li><code>0</code>：显示的数字前面填充’0’而不是默认的空格</li>
<li><code>%</code>：’%%’输出一个单一的’%’</li>
<li><code>var</code>：映射变量(字典参数)</li>
<li><code>m.n.</code>：m 是显示的最小总宽度,n 是小数点后的位数</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python3-string.html">参考</a></p>
<h4 id="增强型格式化字符串"><a href="#增强型格式化字符串" class="headerlink" title="增强型格式化字符串"></a>增强型格式化字符串</h4><p>增强型写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 指定输出位置</span><br><span class="line">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;)</span><br><span class="line"># 输出</span><br><span class="line">&#x27;world hello world&#x27;</span><br><span class="line"></span><br><span class="line"># 指定输出</span><br><span class="line">&quot;姓名：&#123;name&#125;, 年龄 &#123;age&#125;&quot;.format(name=&quot;John&quot;, age=3)</span><br><span class="line"># 输出列表</span><br><span class="line">my_list = [&#x27;First&#x27;, &#x27;Second&#x27;]</span><br><span class="line">print(&quot;姓：&#123;0[0]&#125;, 名 &#123;0[1]&#125;&quot;.format(my_list))</span><br><span class="line"># 格式化输出</span><br><span class="line">&quot;&#123;:.2f&#125;&quot;.format(3.1415926)  # 输出 3.14</span><br><span class="line"># 转义输出</span><br><span class="line">&quot;&#123;&#123;&#125;&#125;&quot;.format()  # 输出 &#123;&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
<th>格式</th>
<th>描述</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;:.2f&#125;</code></td>
<td>保留小数点后两位</td>
<td><code>&#123;:+.2f&#125;</code></td>
<td>带符号保留</td>
<td><code>&#123;:.0f&#125;</code></td>
<td>不带小数</td>
</tr>
<tr>
<td><code>&#123;:0&gt;2d&#125;</code></td>
<td>数字补零 (填充左边, 宽度为2)</td>
<td><code>&#123;:x&lt;4d&#125;</code></td>
<td>数字补x (填充右边, 宽度为4)</td>
<td><code>&#123;:x&lt;4d&#125;</code></td>
<td>数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td><code>&#123;:,&#125;</code></td>
<td>以逗号分隔</td>
<td><code>&#123;:.2%&#125;</code></td>
<td>百分比格式</td>
<td><code>&#123;:.2e&#125;</code></td>
<td>指数记法</td>
</tr>
<tr>
<td><code>&#123;:&gt;10d&#125;</code></td>
<td>右对齐</td>
<td><code>&#123;:&lt;10d&#125;</code></td>
<td>左对齐</td>
<td><code>&#123;:^10d&#125;</code></td>
<td>中间对齐</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-format.html">参考</a></p>
<h4 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h4><p>Python 3.6 新增写法：字符串以<code>f</code>开头，字符串中的变量将会自动运算解析为结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f&#x27;Hello &#123;name&#125;&#x27;</span><br><span class="line">f&#x27;&#123;1+2&#125;&#x27;</span><br><span class="line">f&#x27;&#123;w[&quot;name&quot;]&#125;: &#123;w[&quot;age&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>f-string 使用<code>&#123;content:format&#125;</code>设置字符串格式。其中 content 是替换并填入字符串的内容，可以是变量、表达式或函数等，format 是格式描述符。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
<th>格式</th>
<th>描述</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;</code></td>
<td>左对齐</td>
<td><code>&gt;</code></td>
<td>右对齐</td>
<td><code>^</code></td>
<td>居中</td>
</tr>
<tr>
<td><code>+</code></td>
<td>加正负号</td>
<td><code>-</code></td>
<td>负数加负号</td>
<td><code>空格</code></td>
<td>正数加空格，负数加负号</td>
</tr>
<tr>
<td><code>#</code></td>
<td>进制数切换数字显示方式</td>
<td><code>width</code></td>
<td>指定数字宽度</td>
<td><code>0width</code></td>
<td>指定宽度并高位补0</td>
</tr>
<tr>
<td><code>width.precision</code></td>
<td>宽度.显示精度</td>
<td><code>,</code></td>
<td>千位分隔符</td>
<td><code>_</code></td>
<td>千位分隔符</td>
</tr>
<tr>
<td><code>b/c/d/o/x</code></td>
<td>进制显示方式</td>
<td><code>s</code></td>
<td>字符串</td>
<td><code>e/E/f/F/g/G/%</code></td>
<td>浮点数显示方式</td>
</tr>
<tr>
<td><code>%a/%A/%w/%u</code></td>
<td>星期</td>
<td><code>%d</code></td>
<td>日</td>
<td><code>%b/%B/%m</code></td>
<td>月</td>
</tr>
<tr>
<td><code>%y/%Y</code></td>
<td>年</td>
<td><code>%H/%I</code></td>
<td>小时</td>
<td><code>%p</code></td>
<td>上下午</td>
</tr>
<tr>
<td><code>%M/%S/%f</code></td>
<td>分钟，秒，微秒</td>
<td><code>%j</code></td>
<td>一年的第几天</td>
<td><code>%z</code></td>
<td>UTC偏移量</td>
</tr>
</tbody></table>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c = 12345678</span><br><span class="line">f&#x27;c is &#123;c:015,d&#125;&#x27;   # &#x27;c is 000,012,345,678&#x27;</span><br><span class="line"></span><br><span class="line">e = datetime.datetime.today()</span><br><span class="line">f&#x27;the time is &#123;e:%Y-%m-%d (%a) %H:%M:%S&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="Unicode-字符串"><a href="#Unicode-字符串" class="headerlink" title="Unicode 字符串"></a>Unicode 字符串</h4><p>在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 u。</p>
<p>在Python3中，所有的字符串都是Unicode字符串。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表中的元素的类型可以不同。</p>
<p>运算方式有（设<code>list_a=[1, 2, &quot;a&quot;, True]</code>）：</p>
<ul>
<li>加(<code>list_a + list_b</code>)：列表拼接。</li>
<li>乘(<code>list_a * 2</code>)：列表重复。</li>
<li>切片(<code>list_a[0:-1]</code>, <code>list_a[3:]</code>)：返回列表<code>[1, 2, &quot;a&quot;]</code>，<code>[True]</code>。</li>
</ul>
<p>常用方法：</p>
<ul>
<li>count()：统计某元素出现次数</li>
<li>len()：返回元素个数</li>
<li>append()：在末尾添加元素</li>
<li>pop(n)：移除第n个元素，默认最后一个</li>
<li>index()：返回该元素的索引</li>
<li>insert()：插入一个元素</li>
<li>extend()：在末尾追加另一个列表的所有元素</li>
<li>remove()：移除第一个此元素</li>
<li>reverse()：翻转列表</li>
<li>sort()：元素排序</li>
<li>clear()：清空</li>
<li>copy()：复制</li>
<li>del list[x]：删除第x个元素</li>
</ul>
<p>内置函数：</p>
<ul>
<li>filter：过滤函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line"> </span><br><span class="line">newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</span><br><span class="line">print(newlist)  # [1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure>

<ul>
<li>map：映射函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def square(x):</span><br><span class="line">    return x ** 2</span><br><span class="line"></span><br><span class="line">map(square, [1,2,3,4,5])  # [1, 4, 9, 16, 25]</span><br><span class="line">map(lambda x: x ** 2, [1, 2, 3, 4, 5])  # 使用 lambda 匿名函数</span><br></pre></td></tr></table></figure>

<ul>
<li>reduce：累积函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y) :            # 两数相加</span><br><span class="line">     return x + y</span><br><span class="line"> </span><br><span class="line">reduce(add, [1,2,3,4,5])   # 计算列表和：1+2+3+4+5=15</span><br><span class="line">reduce(lambda x, y: x+y, [1,2,3,4,5])  # 使用 lambda 匿名函数</span><br></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组的元素不可修改。 元组中的元素的类型可以不同。 如果元组包含了对象，那么对象是可以修改的。 构造空元组写作<code>tup1 = ()</code>，构造单元素元组<code>tup2 = (20,)</code>，注意有逗号。</p>
<p>运算方式有（设<code>tuple_a=(1, 2, &quot;a&quot;, True)</code>）：</p>
<ul>
<li>加(<code>tuple_a + tuple_b</code>)：元组拼接。</li>
<li>乘(<code>tuple_a * 2</code>)：元组重复。</li>
<li>切片(<code>tuple_a[0:-1]</code>, <code>tuple_a[3:]</code>)：返回元组<code>(1, 2, &quot;a&quot;)</code>，<code>(True)</code>。</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合中的元素类型必须一致。 集合中的元素不能重复。 创建一个空集合必须使用<code>set()</code>。</p>
<p>运算方式有：</p>
<ul>
<li>求差集(a - b)</li>
<li>求并集(a | b)</li>
<li>求交集(a &amp; b)</li>
<li>求二者中不同时拥有的元素(a ^ b)</li>
</ul>
<p>常用操作：</p>
<ul>
<li>add()：添加元素</li>
<li>update()：批量添加元素</li>
<li>remove()：移除元素，如果不存在，会报错</li>
<li>discard()：移除元素，如果不存在，不会报错</li>
<li>pop()：随机删除一个</li>
<li>len()：求元素个数</li>
<li>clear()：情况集合</li>
<li>x in s：判断使用包含元素</li>
</ul>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典中的元素按照键值对存取。 字典中<code>Key</code>必须是不可变的数据类型（字符串，元组，常量）。 字典中<code>Key</code>值必须是唯一的。</p>
<p>常用操作：</p>
<ul>
<li>clear()：清空字典</li>
<li>copy()：浅拷贝</li>
<li>get()：返回某键的值，否则返回default值</li>
<li>key in dict：判断是否有该key</li>
<li>pop()：删除某个key</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>int()：转换为整型，可以接受：字符串，Bytes对象，数字。 float()：转换为浮点，可以接受：字符串，数字。 str()：转换为字符串，可接受几乎所有对象，转换结果适用于人类阅读。 repr()：转换为字符串，可接受几乎所有对象，转换结果适用于机器使用。 eval()：将字符串作为Python语句执行，返回执行结果。 tuple()：转化为元组，可以接受：列表，字符串等。 list()：转化为列表，可以接受：元组，字符串等。 set()：转化为集合。 dict()：转化为字典，可以接受：(key, value)的序列。 chr()：整数转化为字符。 ord()：字符转整数。 unichr()：整数转换为Unicode字符。 hex()：整数转十六进制字符串。 oct()：整数转八进制字符串。</p>
<p>chr()：将数字按照ASCII转化为字符 ord()：转换ASCII字符为整数 bytearray()：返回一个Byte数组，参数是整数n，则初始化数组长度为n；如果是字符串，则将字符串转换为Bytes compile(source, filename, mode)：将字符串编译为字节码，mode可以为exec、eval、single</p>
<h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p>在Python中，我们创建变量，传递变量是不需要注明类型的。但是这也造成了不便。因此 Python 3 提供了类型注解的功能，来表明变量类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># x:int 注明x是一个int型变量，-&gt; 指明了返回值类型为int</span><br><span class="line">def add(x:int, y:int) -&gt; int:</span><br><span class="line">    # 声明一个int行变量，并赋值</span><br><span class="line">    z:int = 10</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure>

<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>input()：标准输入 print()：标准输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 输出的结尾：以逗号结尾，默认是以换行结尾</span><br><span class="line">print(end=&#x27;,&#x27;)</span><br><span class="line"># 输出对象间隔号：以逗号间隔，默认是空格</span><br><span class="line">print(sep=&#x27;,&#x27;)</span><br><span class="line"># 输出到文件</span><br><span class="line">print(file=&#x27;&#x27;)</span><br><span class="line"># 是否强制刷新流</span><br><span class="line">print(flush=&#x27;,&#x27;)</span><br></pre></td></tr></table></figure>

<p>exec()：执行Python语句，无返回值 eval()：将给定表达式用Python执行，并返回执行结果 execfile(filename)：执行一个文件，返回执行结果 file()：创建一个FILE对象，同open() memoryview()：查看对象的在内存的存储形式，对使用缓冲区的地方非常友好，尤其是对str与bytearray</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = &#x27;aaaaaa&#x27;</span><br><span class="line">ma = memoryview(a)</span><br><span class="line">ma.readonly  # True，只读的memoryview</span><br><span class="line">mb = ma[:2]  # 不会产生新的字符串</span><br><span class="line"></span><br><span class="line">a = bytearray(&#x27;aaaaaa&#x27;)</span><br><span class="line">ma = memoryview(a)</span><br><span class="line">ma.readonly      # False，可写的memoryview</span><br><span class="line">mb = ma[:2]      # 不会会产生新的bytearray</span><br><span class="line">mb[:2] = &#x27;bb&#x27;    # 对mb的改动就是对ma的改动</span><br><span class="line">mb.tobytes()     # &#x27;bb&#x27; </span><br><span class="line">ma.tobytes()     # &#x27;bbaaaa&#x27;</span><br></pre></td></tr></table></figure>

<p>globals()：返回当前位置的全局变量，字典形式 locals()：返回当前位置的局部变量，字典形式</p>
<p>id()：获取对象的内存地址 hash()：返回对象的哈希值 super()：调用父类 vars()：将对象转化为字典</p>
<p>reload()：重新加载模块 <code>__import__</code>()：动态加载类或模块 help()：查看模块或函数的帮助信息</p>
<h3 id="查看类型"><a href="#查看类型" class="headerlink" title="查看类型"></a>查看类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type(x)  # 查看变量的类型，子类与父类不一致。</span><br><span class="line">isinstance(x, int)  # 查看变量是否是某种类型，子类和父类被认为一直。</span><br><span class="line">issubclass(father, son)  # 判断是否为子类</span><br></pre></td></tr></table></figure>

<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 遍历列表</span><br><span class="line">for x in x_list:</span><br><span class="line">    pass</span><br><span class="line"># 遍历字符串</span><br><span class="line">for c in &quot;abcdefg&quot;:</span><br><span class="line">    pass</span><br><span class="line"># 带索引遍历</span><br><span class="line">for i, name in enumerate(name_list, start_index):</span><br><span class="line">    print(f&#x27;index is &#123;i&#125;,name is &#123;name&#125;&#x27;)</span><br><span class="line"># 打包成元组遍历 a = [1,2,3], c = [4,5,6,7,8], zip(a,c) --&gt; [(1, 4), (2, 5), (3, 6)]</span><br><span class="line">for i in zip(albums, years):</span><br><span class="line">    print(i)</span><br><span class="line"># 单行 for 循环</span><br><span class="line">s.split() for s in sentence</span><br><span class="line"># 相当于</span><br><span class="line">for s in sentence:</span><br><span class="line">    s.split()</span><br><span class="line"># 遍历字典</span><br><span class="line">for k, v in knights.items():</span><br><span class="line">    print(k, v)</span><br><span class="line"># 遍历排序后的集合</span><br><span class="line">for f in sorted(set(basket)):</span><br><span class="line">    print(f)</span><br></pre></td></tr></table></figure>

<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list=[1,2,3,4]</span><br><span class="line">it = iter(list)    # 创建迭代器对象</span><br><span class="line">for x in it:</span><br><span class="line">    print (x, end=&quot; &quot;)</span><br><span class="line">it = iter(list)    # 创建迭代器对象</span><br><span class="line">print (next(it))   # 输出迭代器的下一个元素</span><br><span class="line">print (next(it))   # 输出迭代器的下一个元素</span><br></pre></td></tr></table></figure>

<p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <code>__next__()</code> 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MyNumbers:</span><br><span class="line">  def __iter__(self):</span><br><span class="line">    self.a = 1</span><br><span class="line">    return self</span><br><span class="line"> </span><br><span class="line">  def __next__(self):</span><br><span class="line">    if self.a &lt;= 20:</span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += 1</span><br><span class="line">      return x</span><br><span class="line">    else:</span><br><span class="line">      raise StopIteration</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"> </span><br><span class="line">for x in myiter:</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure>

<p>在 Python 中，使用了 yield 的函数被称为生成器。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
<p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"> </span><br><span class="line">def fibonacci(n): # 生成器函数 - 斐波那契</span><br><span class="line">    a, b, counter = 0, 1, 0</span><br><span class="line">    while True:</span><br><span class="line">        if (counter &gt; n): </span><br><span class="line">            return</span><br><span class="line">        yield a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += 1</span><br><span class="line">f = fibonacci(10) # f 是一个迭代器，由生成器返回生成</span><br><span class="line"> </span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        print (next(f), end=&quot; &quot;)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>

<h3 id="不定长传参"><a href="#不定长传参" class="headerlink" title="不定长传参"></a>不定长传参</h3><p>转为元组传入 <code>*</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def printinfo( arg1, *vartuple ):</span><br></pre></td></tr></table></figure>

<p>转为字典传入 <code>**</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def printinfo( arg1, **var_args_dict ):</span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = lambda arg1, arg2: arg1 + arg2</span><br></pre></td></tr></table></figure>

<h3 id="强制位置参数"><a href="#强制位置参数" class="headerlink" title="强制位置参数"></a>强制位置参数</h3><p><code>/</code>前面的参数不能使用关键字参数。 <code>*</code>后面的参数必须使用关键字参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(a, b, /, c, d, *, e, f):</span><br><span class="line">    print(a, b, c, d, e, f)</span><br></pre></td></tr></table></figure>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><p>可以使用列表作为堆栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack = [1, 2, 3]</span><br><span class="line">stack.append(4)</span><br><span class="line">x = stack.pop()</span><br></pre></td></tr></table></figure>

<p>可以使用模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from queue import LifoQueue</span><br><span class="line">stack = LifoQueue()</span><br><span class="line">stack.put(1)</span><br><span class="line">while not stack.empty():</span><br><span class="line">    x = stack.get()</span><br></pre></td></tr></table></figure>

<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>使用列表作为队列，但是效率不高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">que = [1, 2, 3]</span><br><span class="line">que.append(4)</span><br><span class="line">x = stack.popleft()</span><br></pre></td></tr></table></figure>

<p>可以使用模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line">que = Queue()</span><br><span class="line">q.put(1)</span><br><span class="line">while not q.empty():</span><br><span class="line">    x = q.get()</span><br></pre></td></tr></table></figure>

<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from queue import PriorityQueue</span><br><span class="line">q = PriorityQueue()</span><br><span class="line">q.put(Task(5, &#x27;Mid-level job&#x27;))</span><br><span class="line">while not q.empty():</span><br><span class="line">    next_job = q.get()</span><br><span class="line"></span><br><span class="line">class Task(object):</span><br><span class="line">    def __init__(self, priority, description):</span><br><span class="line">        self.priority = priority</span><br><span class="line">        self.description = description</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 运算符重载</span><br><span class="line">    def __lt__(self, other):</span><br><span class="line">        return self.priority &lt; other.priority</span><br></pre></td></tr></table></figure>

<h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><p>可以方便用于创建列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vec1 = [2, 4, 6]</span><br><span class="line">vec2 = [4, 3, -9]</span><br><span class="line">[3*x for x in vec1]                # [6, 12, 18]</span><br><span class="line">[x*y for x in vec1 for y in vec2]  # [8, 6, -18, 16, 12, -36, 24, 18, -54]</span><br></pre></td></tr></table></figure>

<h3 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h3><p><code>__name__</code>属性来使该程序块仅在该模块自身运行时执行。</p>
<p>dir() 函数可以找到模块内定义的所有名称。以一个字符串列表的形式返回：</p>
<p>包：管理 Python 模块命名空间的形式，如sound包下的effects包下的echo模块，使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sound.effects.echo</span><br></pre></td></tr></table></figure>

<p>对应的目录结构为：</p>
<ul>
<li>sound&#x2F;<ul>
<li><code>__init__.py</code></li>
<li>effects&#x2F;<ul>
<li><code>__init__.py</code></li>
<li>echo.py</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>包的下面必须有<code>__init__.py</code>文件（可以是空文件），否则将不会识别为包。</p>
<p>如果包定义文件 <code>__init__.py</code> 存在一个叫做 <code>__all__</code> 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。</p>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>使用<code>open()</code>可以打开文件，其完整的参数表为：</p>
<ul>
<li>file: 必需，文件路径（相对或者绝对路径）。</li>
<li>mode: 可选，文件打开模式</li>
<li>buffering: 设置缓冲</li>
<li>encoding: 一般使用utf8</li>
<li>errors: 报错级别</li>
<li>newline: 区分换行符</li>
<li>closefd: 传入的file参数类型</li>
<li>opener:</li>
</ul>
<p>mode指定了文件打开模式，默认为只读，常见方式有：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
<th>模式</th>
<th>描述</th>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>写模式，文件已存在则报错</td>
<td>b</td>
<td>二进制</td>
<td>+</td>
<td>读写</td>
</tr>
<tr>
<td>r</td>
<td>只读</td>
<td>rb</td>
<td>只读，二进制</td>
<td>r+</td>
<td>读写</td>
</tr>
<tr>
<td>rb+</td>
<td>读写，二进制</td>
<td>w</td>
<td>只写</td>
<td>wb</td>
<td>只写，二进制</td>
</tr>
<tr>
<td>w+</td>
<td>读写</td>
<td>wb+</td>
<td>读写，二进制</td>
<td>a</td>
<td>追加写</td>
</tr>
<tr>
<td>ab</td>
<td>追加写，二进制</td>
<td>a+</td>
<td>追加读写</td>
<td>ab+</td>
<td>追加读写，二进制</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">f = open(filename)</span><br><span class="line"># 读取n个字符或字节，默认是全部内容</span><br><span class="line">f.read(n)</span><br><span class="line"># 读取一行，如果为空，说明已经最后一行了</span><br><span class="line">f.readline()</span><br><span class="line"># 读取所有行</span><br><span class="line">f.readlines()</span><br><span class="line"># 写入</span><br><span class="line">f.write(data)</span><br><span class="line"># 返回当前指针位置</span><br><span class="line">f.tell()</span><br><span class="line"># 移动指针位置：0 从开头向后移动m个字节，1 从当前位置向后移动m个字节，2 从结尾向后移动m个字节</span><br><span class="line">f.seek(m, 0)</span><br><span class="line"># 获取文件描述符</span><br><span class="line">f.fileno()</span><br><span class="line"># 判断是否为终端设备</span><br><span class="line">f.isatty()</span><br><span class="line"># 刷新缓冲区到文件</span><br><span class="line">f.flush()</span><br><span class="line"># 关闭文件，释放资源</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>如果觉得打开文件再关闭文件操作繁琐，Python还提供了<code>with as</code>功能，可以打开后不管释放：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 执行完毕自动释放</span><br><span class="line">with open(&quot;/tmp/file.txt&quot;) as file:</span><br><span class="line">    data = file.read()</span><br></pre></td></tr></table></figure>

<p>with语句不仅可以用来操作文件，线程等资源也可以使用。</p>
<p>pickle模块，可以用来序列化和反序列化对象。利用这个模块，我们可以用来保存数据结构到文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line"></span><br><span class="line">pickle.dump(obj, file)</span><br><span class="line">x = pickle.load(file)</span><br></pre></td></tr></table></figure>

<h3 id="OS-模块"><a href="#OS-模块" class="headerlink" title="OS 模块"></a>OS 模块</h3><p>目录与权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 检验权限模式，尝试使用UserID，GroupID访问目录，检验是否有权限访问。mode：</span><br><span class="line"># os.F_OK 测试path是否存在。</span><br><span class="line"># os.R_OK 测试path是否可读。</span><br><span class="line"># os.W_OK 测试path是否可写。</span><br><span class="line"># os.X_OK 测试path是否可执行。</span><br><span class="line">os.access(path, mode)</span><br><span class="line"></span><br><span class="line"># 更改当前进程的看到的根目录</span><br><span class="line"># 例如 os.chroot(&#x27;/tmp&#x27;)</span><br><span class="line"># 则 对于进程&#x27;/&#x27;目录就是系统的&#x27;/tmp&#x27;目录</span><br><span class="line">os.chroot(path)</span><br><span class="line"></span><br><span class="line"># 切换工作目录</span><br><span class="line">os.chdir(path)</span><br><span class="line"># 获取工作目录</span><br><span class="line">os.getcwd()</span><br><span class="line"></span><br><span class="line"># 更改权限</span><br><span class="line">os.chmod(path, mode)</span><br><span class="line"># 更改文件所有者</span><br><span class="line">os.chown(path, uid, gid)</span><br><span class="line"></span><br><span class="line"># 获取路劲下的文件和文件夹</span><br><span class="line">os.listdir(path)</span><br><span class="line"># 创建路径，mode为权限 0o755</span><br><span class="line">os.makedirs(path[, mode])</span><br><span class="line"># 删除路径为path的文件</span><br><span class="line">os.remove(path)</span><br><span class="line"># 删除空目录，如果非空则异常</span><br><span class="line">os.rmdir(path)</span><br><span class="line"># 重命名</span><br><span class="line">os.rename(src, dst)</span><br><span class="line"># 获取path信息</span><br><span class="line">os.stat(path)</span><br><span class="line"># 获取文件系统信息</span><br><span class="line">os.statvfs(path)</span><br></pre></td></tr></table></figure>

<p>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 获取文件描述符</span><br><span class="line">fx = f.fileno()</span><br><span class="line">fx = os.open(filepath, os.O_RDONLY)</span><br><span class="line"># 关闭文件</span><br><span class="line">os.close(fx)</span><br><span class="line"># 关闭所有文件，左闭右开</span><br><span class="line">os.closerange(fx, fy)</span><br><span class="line"># 复制文件描述符</span><br><span class="line">os.dup(fx)</span><br><span class="line"># 通过描述符改变工作目录，fx指向目录</span><br><span class="line">os.fchdir(fx)</span><br><span class="line"># 修改文件所有权</span><br><span class="line">os.fchown(fx, uid, gid)</span><br><span class="line"># 强制写入磁盘</span><br><span class="line">os.fdatasync(fx)</span><br><span class="line"># 打开的文件的系统配置信息，name，&#x27;PC_LINK_MAX&#x27; 文件最大连接数，&#x27;PC_NAME_MAX&#x27; 文件名最长长度</span><br><span class="line">os.fpathconf(fx, name)</span><br><span class="line"># 获取描述符状态，包括设备信息，文件修改时间，用户ID等</span><br><span class="line">os.fstat(fx)</span><br><span class="line"># 获取描述符状态，包括文件系统块大小，可用块数，文件结点总数</span><br><span class="line">os.fstatvfs(fx) </span><br><span class="line"></span><br><span class="line"># 创建命名管道，mode为权限 默认0o666</span><br><span class="line">os.mkfifo(path[, mode])</span><br><span class="line"># 打开一个终端</span><br><span class="line">os.openpty()</span><br><span class="line"># 创建一个管道</span><br><span class="line">os.pipe()</span><br><span class="line"># 从command打开一个管道，command 使用的命令，mode r默认 w，bufsize 0无缓冲 1有缓冲</span><br><span class="line">os.popen(command[, mode[, bufsize]])</span><br></pre></td></tr></table></figure>

<p>os.path 模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># 绝对路径</span><br><span class="line">os.path.abspath(path)</span><br><span class="line"># 文件名</span><br><span class="line">os.path.basename(path)</span><br><span class="line"># 文件路径</span><br><span class="line">os.path.dirname(path)</span><br><span class="line"># 路径是否存在</span><br><span class="line">os.path.exists(path)</span><br><span class="line"># 文件访问时间</span><br><span class="line">os.path.getatime(path)</span><br><span class="line"># 文件修改时间</span><br><span class="line">os.path.getmtime(path)</span><br><span class="line"># 路径创建时间</span><br><span class="line">os.path.getctime(path)</span><br><span class="line"># 文件大小</span><br><span class="line">os.path.getsize(path)</span><br><span class="line"># 是否为绝对路径</span><br><span class="line">os.path.isabs(path)</span><br><span class="line"># 是否为文件</span><br><span class="line">os.path.isfile(path)</span><br><span class="line"># 是否为目录</span><br><span class="line">os.path.isdir(path)</span><br><span class="line"># 是否为链接</span><br><span class="line">os.path.islink(path)</span><br><span class="line"># 是否为挂载点</span><br><span class="line">os.path.ismount(path)</span><br><span class="line"># 合并目录与文件名</span><br><span class="line">os.path.join(path1[, path2[, ...]])</span><br><span class="line"># 转换path大小写与斜杠</span><br><span class="line">os.path.normcase(path)</span><br><span class="line"># 规范path形式</span><br><span class="line">os.path.normpath(path)</span><br><span class="line"># 返回path真实路径</span><br><span class="line">os.path.realpath(path)</span><br><span class="line"># 判断目录，文件是否相同</span><br><span class="line">os.path.samefile(path1, path2)</span><br><span class="line"># 判断是否指向同一文件</span><br><span class="line">os.path.sameopenfile(fp1, fp2)</span><br><span class="line"># 分割路径与文件名 元组</span><br><span class="line">os.path.split(path)</span><br><span class="line"># 返回驱动器名和路径 windows下 元组</span><br><span class="line">os.path.splitdrive(path)</span><br><span class="line"># 分割路径，返回路径名 扩展名 元组</span><br><span class="line">os.path.splitext(path)</span><br><span class="line"># 分割为加载点与文件</span><br><span class="line">os.path.splitunc(path)</span><br><span class="line"># 遍历path，每个目录都调用visit函数 visit(arg, dirname 目录, names 目录下所有文件名)</span><br><span class="line">os.path.walk(path, visit, arg)</span><br></pre></td></tr></table></figure>

<h3 id="异常与断言"><a href="#异常与断言" class="headerlink" title="异常与断言"></a>异常与断言</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    pass</span><br><span class="line"># except 后可加元组，可以包含多个Exception</span><br><span class="line">except (ZeroDivisionError, KeyboardInterrupt):</span><br><span class="line">    pass</span><br><span class="line">else:</span><br><span class="line">    pass</span><br><span class="line">except Exception:</span><br><span class="line">    pass</span><br><span class="line"># finally不论发生异常与否都会执行，如果异常未被接住，则会在finally执行完毕后抛出</span><br><span class="line">finally:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>Python assert（断言）用于判断一个表达式，在表达式条件为 False 的时候触发异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 语法 assert expression[, arguments] </span><br><span class="line"># 例如</span><br><span class="line">assert 3 + 2 == 5, &#x27;结果不为 5&#x27;</span><br><span class="line"># 输出 AssertionError: 结果不为 5</span><br></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>类的属性与方法的访问权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 默认为公有</span><br><span class="line">def fun():</span><br><span class="line"># 保护 一个下划线</span><br><span class="line">def _fun():</span><br><span class="line"># 私有 两个下划线</span><br><span class="line">def __fun():</span><br></pre></td></tr></table></figure>

<p>类的专用方法有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 构造函数</span><br><span class="line">def __init__():</span><br><span class="line"># 析构函数</span><br><span class="line">def __del__():</span><br><span class="line"># 打印</span><br><span class="line">def __repr__():</span><br><span class="line"># 按索引赋值</span><br><span class="line">def __setitem__():</span><br><span class="line"># 按索引取值</span><br><span class="line">def __getitem__():</span><br><span class="line"># 获取长度</span><br><span class="line">def __len__():</span><br><span class="line"># 比较</span><br><span class="line">def __cmp__():</span><br><span class="line"># 调用</span><br><span class="line">def __call__():</span><br><span class="line"># 运算符重载</span><br><span class="line"># 加</span><br><span class="line">def __add__():</span><br><span class="line"># 减</span><br><span class="line">def __sub__():</span><br><span class="line"># 乘</span><br><span class="line">def __mul__():</span><br><span class="line"># 除</span><br><span class="line">def __truediv__():</span><br><span class="line"># 取余</span><br><span class="line">def __mod__():</span><br><span class="line"># 乘方</span><br><span class="line">def __pow__():</span><br><span class="line"># 小于</span><br><span class="line">def __lt__():</span><br><span class="line"># 等于</span><br><span class="line">def __eq__():</span><br><span class="line"># 大于</span><br><span class="line">def __gt__():</span><br><span class="line"># 小于等于</span><br><span class="line">def __le__():</span><br><span class="line"># 不等于</span><br><span class="line">def __ne__():</span><br><span class="line"># 大于等于</span><br><span class="line">def __ge__():</span><br></pre></td></tr></table></figure>

<p>在类的继承中，子类不重写 <code>__init__</code>，实例化子类时，会自动调用父类定义的 <code>__init__</code>。子类重写 <code>__init__</code>，就不会调用父类的初始化函数。如果都想执行，可以使用super()调用。</p>
<h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><h4 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h4><p>shutil模块提供了针对日常的文件和目录管理任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import shutil</span><br><span class="line">shutil.copyfile(&#x27;a.txt&#x27;,&#x27;b.txt&#x27;)</span><br><span class="line">shutil.move(&#x27;/dir_a/a.txt&#x27;,&#x27;/dir_b&#x27;)</span><br></pre></td></tr></table></figure>

<h4 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h4><p>glob模块提供了一个函数用于从目录通配符搜索中生成文件列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import glob</span><br><span class="line">glob.glob(&#x27;*.py&#x27;)  # [&#x27;primes.py&#x27;, &#x27;random.py&#x27;, &#x27;quote.py&#x27;]</span><br></pre></td></tr></table></figure>

<h4 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h4><p>sys可以读取命令行参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">print(sys.argv)  # [&#x27;demo.py&#x27;, &#x27;arg1&#x27;, &#x27;arg2&#x27;, &#x27;arg3&#x27;]</span><br></pre></td></tr></table></figure>

<p>也可以重定向输出，如stdin，stdout，stderr</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys.stderr.write(&#x27;Warning, log file not found starting a new one\n&#x27;)</span><br></pre></td></tr></table></figure>

<h4 id="re"><a href="#re" class="headerlink" title="re"></a>re</h4><p>re模块为高级字符串处理提供了正则表达式工具。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">re.findall(r&#x27;\bf[a-z]*&#x27;, &#x27;which foot or hand fell fastest&#x27;)</span><br><span class="line"># [&#x27;foot&#x27;, &#x27;fell&#x27;, &#x27;fastest&#x27;]</span><br><span class="line">re.sub(r&#x27;(\b[a-z]+) \1&#x27;, r&#x27;\1&#x27;, &#x27;cat in the the hat&#x27;)</span><br><span class="line"># &#x27;cat in the hat&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h4><p>datetime模块为日期和时间处理同时提供了简单和复杂的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from datetime import date, time, datetime</span><br><span class="line"># 格式化输出</span><br><span class="line">now = date.today()</span><br><span class="line">now.strftime(&quot;%m-%d-%y. %d %b %Y is a %A on the %d day of %B.&quot;)</span><br><span class="line"># &#x27;12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.&#x27;</span><br><span class="line"></span><br><span class="line"># 日期天数差 </span><br><span class="line">birthday = date(1964, 7, 31)</span><br><span class="line">age = now - birthday</span><br><span class="line">age.days  # 14368</span><br><span class="line"></span><br><span class="line"># 当前时间戳</span><br><span class="line">time_stamp = time.time()</span><br><span class="line"># 转为日期时间</span><br><span class="line">datetime.fromtimestamp(time_stamp)</span><br><span class="line"># 转为时间戳</span><br><span class="line">int(time.mktime(today.timetuple()))</span><br><span class="line"># 补时差 </span><br><span class="line">today + datetime.timedelta(hours=8)</span><br></pre></td></tr></table></figure>

<h4 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h4><p>以下模块直接支持通用的数据打包和压缩格式：zlib，gzip，bz2，zipfile，以及 tarfile。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import zlib</span><br><span class="line">s = b&#x27;witch which has which witches wrist watch&#x27;</span><br><span class="line">len(s)  # 41</span><br><span class="line">t = zlib.compress(s)</span><br><span class="line">len(t)  # 37</span><br><span class="line">zlib.decompress(t)  # b&#x27;witch which has which witches wrist watch&#x27;</span><br><span class="line">zlib.crc32(s)  # 226805979</span><br></pre></td></tr></table></figure>

<h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from timeit import Timer</span><br><span class="line">Timer(&#x27;t=a; a=b; b=t&#x27;, &#x27;a=1; b=2&#x27;).timeit()</span><br><span class="line"></span><br><span class="line"># 测试函数调用时间</span><br><span class="line">def test():</span><br><span class="line">    L = []</span><br><span class="line">    for i in range(100):</span><br><span class="line">        L.append(i)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    import timeit</span><br><span class="line">    print(timeit.timeit(&quot;test()&quot;, setup=&quot;from __main__ import test&quot;))</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>doctest模块提供了一个工具，扫描模块并根据程序中内嵌的文档字符串执行测试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def average(values):</span><br><span class="line">    &quot;&quot;&quot;Computes the arithmetic mean of a list of numbers.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; print(average([20, 30, 70]))</span><br><span class="line">    40.0</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return sum(values) / len(values)</span><br><span class="line"></span><br><span class="line">import doctest</span><br><span class="line">doctest.testmod()   # 根据所给注释，自动验证本文档所有函数 </span><br></pre></td></tr></table></figure>

<p>unittest模块可以在一个独立的文件里提供一个更全面的测试集。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">class TestStatisticalFunctions(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    def test_average(self):</span><br><span class="line">        self.assertEqual(average([20, 30, 70]), 40.0)</span><br><span class="line">        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)</span><br><span class="line">        self.assertRaises(ZeroDivisionError, average, [])</span><br><span class="line">        self.assertRaises(TypeError, average, 20, 30, 70)</span><br><span class="line"></span><br><span class="line">unittest.main()  # 从命令行调用，执行所有测试</span><br></pre></td></tr></table></figure>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
<th>模式</th>
<th>描述</th>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>开头</td>
<td><code>$</code></td>
<td>末尾</td>
<td><code>.</code></td>
<td>任意字符，除了换行符</td>
</tr>
<tr>
<td><code>[...]</code></td>
<td>一组字符</td>
<td><code>[^...]</code></td>
<td>不在<code>[]</code>中的字符</td>
<td><code>re*</code></td>
<td>匹配0个或多个的表达式</td>
</tr>
<tr>
<td><code>re+</code></td>
<td>匹配1个或多个的表达式</td>
<td><code>re?</code></td>
<td>匹配0个或1个表达式片段</td>
<td><code>re&#123;n&#125;</code></td>
<td>匹配n个前面表达式片段</td>
</tr>
<tr>
<td><code>re&#123;n,&#125;</code></td>
<td>精确匹配n个前面表达式片段</td>
<td><code>re&#123;n,m&#125;</code></td>
<td>匹配 n 到 m 次由前面的正则表达式片段</td>
<td>&#96;a</td>
<td>b&#96;</td>
</tr>
<tr>
<td><code>(re)</code></td>
<td>匹配括号内的表达式</td>
<td><code>(?#...)</code></td>
<td>注释</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>\w</code></td>
<td>数字字母下划线</td>
<td><code>\W</code></td>
<td>非数字字母下划线</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>\s</code></td>
<td>任意空白字符</td>
<td><code>\S</code></td>
<td>任意非空字符</td>
<td><code>\d</code></td>
<td>任意数字</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>任意非数字</td>
<td><code>\A</code></td>
<td>字符串开始</td>
<td><code>\Z</code></td>
<td>字符串结束或换行前</td>
</tr>
<tr>
<td><code>\z</code></td>
<td>字符串结束</td>
<td><code>\G</code></td>
<td>最后匹配完成的位置</td>
<td><code>\b</code></td>
<td>单词边界</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>非单词边界</td>
<td><code>\n</code>,<code>\t</code></td>
<td>换行符，制表符</td>
<td><code>\1</code>,…,<code>\9</code></td>
<td>匹配第n个分组的内容</td>
</tr>
</tbody></table>
<p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># pattern 正则表达式</span><br><span class="line"># string 要匹配的字符串</span><br><span class="line"># flag 标志位</span><br><span class="line"># 未匹配返回None</span><br><span class="line">print(re.match(&#x27;a&#x27;, &#x27;a.b.c&#x27;).span())  # span 返回匹配开始与结束的位置 返回(0, 1)</span><br><span class="line">print(re.match(&#x27;c&#x27;, &#x27;a.b.c&#x27;)) # 返回 None</span><br><span class="line"></span><br><span class="line">obj = re.match(pattern, string, flags=0)</span><br><span class="line">obj.group()  # 原始对象</span><br><span class="line">obj.group(1) # 获取匹配的值</span><br><span class="line">obj.group(2) # 获取匹配的值</span><br></pre></td></tr></table></figure>

<p>re.search 扫描整个字符串并返回第一个成功的匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern, string, flags=0).span() # 返回匹配的位置</span><br></pre></td></tr></table></figure>

<p>re.sub用于替换字符串中的匹配项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># repl 替换的字符串，也可以是函数</span><br><span class="line"># count 最大替换次数</span><br><span class="line"># 返回 替换次数</span><br><span class="line">re.sub(pattern, repl, string, count=0, flags=0)</span><br></pre></td></tr></table></figure>

<p>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pt = re.compile(pattern[, flags])</span><br><span class="line"># 例如</span><br><span class="line">pt = re.compile(r&#x27;\d+&#x27;)</span><br><span class="line">m = pt.match(&quot;abcd&quot;)</span><br></pre></td></tr></table></figure>

<p>findall()在字符串中找到正则表达式所匹配的所有子串，并返回一个列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pt.findall(string[, pos[, endpos]])</span><br><span class="line"># 例如</span><br><span class="line">pt = re.compile(pattern[, flags])</span><br><span class="line">pt.findall(&quot;abcd&quot;)</span><br></pre></td></tr></table></figure>

<p>split 方法按照能够匹配的子串将字符串分割后返回列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.split(pattern, string[, maxsplit=0, flags=0])</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://regexone.com/">正则表达式练习</a></p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP请求头部格式为：<code>HTTP 字段名: 字段内容</code>，主要有以下几种：</p>
<table>
<thead>
<tr>
<th>头部</th>
<th>描述</th>
<th>头部</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Content-type:text&#x2F;html</td>
<td>请求的MIME信息</td>
<td>Expires: Date</td>
<td>响应过期的日期和时间</td>
</tr>
<tr>
<td>Location: URL</td>
<td>重定向接收方到非请求URL的位置</td>
<td>Last-modified: Date</td>
<td>请求资源的最后修改时间</td>
</tr>
<tr>
<td>Content-length: N</td>
<td>请求的内容长度</td>
<td>Set-Cookie: String</td>
<td>设置Http Cookie</td>
</tr>
</tbody></table>
<p>HTTP响应头部还包括了：</p>
<ul>
<li>Allow：服务器支持的协议</li>
<li>Content-Encoding：编码</li>
<li>Location：如果是重定向301，则跳转到该页面</li>
<li>Date：服务器时间</li>
<li>Last-Modified：文档最后修改时间</li>
<li>Server：服务器名字</li>
<li>Set-Cookie：设置cookie</li>
</ul>
<p>比较复杂的是Content-type，它包含：</p>
<ul>
<li>text&#x2F;html ： HTML格式</li>
<li>text&#x2F;plain ：纯文本格式</li>
<li>text&#x2F;xml ： XML格式</li>
<li>image&#x2F;gif ：gif图片格式</li>
<li>image&#x2F;jpeg ：jpg图片格式</li>
<li>image&#x2F;png：png图片格式</li>
<li>application&#x2F;xhtml+xml：XHTML格式</li>
<li>application&#x2F;xml：XML数据格式</li>
<li>application&#x2F;atom+xml：Atom XML聚合格式</li>
<li>application&#x2F;json：JSON数据格式</li>
<li>application&#x2F;pdf：pdf格式</li>
<li>application&#x2F;msword：Word文档格式</li>
<li>application&#x2F;octet-stream：二进制流数据（如常见的文件下载）</li>
<li>multipart&#x2F;form-data：需要在表单中进行文件上传时，就需要使用该格式</li>
</ul>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket API 中定义的协议族（family）参数是指调用者期待返回的套接字地址结构的类型，主要包含（AF有时也写作PF）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">AF_UNSPEC 0  /* 未指定 */ </span><br><span class="line">AF_UNIX 1    /* Unix domain sockets */</span><br><span class="line">AF_LOCAL 1   /* POSIX name for AF_UNIX */</span><br><span class="line">AF_INET 2    /* IPv4 */</span><br><span class="line">AF_AX25 3    /* 业余无线电 AX.25 */</span><br><span class="line">AF_IPX 4     /* Novell IPX */</span><br><span class="line">AF_APPLETALK 5/* AppleTalk 地址 */</span><br><span class="line">AF_NETROM 6  /* 业余无线电 NET/ROM */</span><br><span class="line">AF_BRIDGE 7  /* 多协议网桥 */</span><br><span class="line">AF_ATMPVC 8  /* ATM PVCs */</span><br><span class="line">AF_X25 9     /* 保留 for X.25 project */</span><br><span class="line">AF_INET6 10  /* IPv6 */</span><br><span class="line">AF_ROSE 11   /* 业余无线电 X.25 PLP */</span><br><span class="line">AF_DECnet 12 /* 保留 for DECnet project */</span><br><span class="line">AF_NETBEUI 13/* 保留 for 802.2LLC project*/</span><br><span class="line">AF_SECURITY 14/* Security callback pseudo AF */</span><br><span class="line">AF_KEY 15     /* PF_KEY key management API */</span><br><span class="line">AF_NETLINK 16  /* Only for Linux */</span><br><span class="line">AF_ROUTE AF_NETLINK /* Alias to emulate 4.4BSD */</span><br><span class="line">AF_PACKET 17  /* Packet family */</span><br><span class="line">AF_ASH 18     /* Ash */</span><br><span class="line">AF_ECONET 19  /* Acorn Econet */</span><br><span class="line">AF_ATMSVC 20  /* ATM SVCs */</span><br><span class="line">AF_RDS 21     /* RDS sockets */</span><br><span class="line">AF_SNA 22     /* Linux SNA Project (nutters!) */</span><br><span class="line">AF_IRDA 23    /* IRDA sockets */</span><br><span class="line">AF_PPPOX 24   /* PPPoX sockets */</span><br><span class="line">AF_WANPIPE 25 /* Wanpipe API Sockets */</span><br><span class="line">AF_LLC 26     /* Linux LLC */</span><br><span class="line">AF_IB 27      /* Native InfiniBand address */</span><br><span class="line">AF_CAN 29     /* Controller Area Network      */</span><br><span class="line">AF_TIPC 30    /* TIPC sockets */</span><br><span class="line">AF_BLUETOOTH 31/* Bluetooth sockets */</span><br><span class="line">AF_IUCV 32    /* IUCV sockets */</span><br><span class="line">AF_RXRPC 33   /* RxRPC sockets */</span><br><span class="line">AF_ISDN 34    /* mISDN sockets */</span><br><span class="line">AF_PHONET 35  /* Phonet sockets */</span><br><span class="line">AF_IEEE802154 36/* IEEE802154 sockets */</span><br><span class="line">AF_CAIF 37    /* CAIF sockets */</span><br><span class="line">AF_ALG 38     /* Algorithm sockets */</span><br><span class="line">AF_NFC 39     /* NFC sockets */</span><br><span class="line">AF_VSOCK 40   /* vSockets */</span><br><span class="line">AF_MAX 41     /* 保留 */</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.addressfamily?view=netframework-4.8">参考</a></p>
<p>定义的类型（type）包含：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SOCK_STREAM = 1,   // TCP</span><br><span class="line">SOCK_DGRAM = 2,    // UDP</span><br><span class="line">SOCK_RAW = 3,      // 原始类型，可以自定义</span><br><span class="line">SOCK_RDM = 4,      // 提供可靠的数据包连接</span><br><span class="line">SOCK_SEQPACKET= 5, // 提供连续可靠的数据包连接</span><br><span class="line">SOCK_DCCP = 6,     // 数据报拥塞控制协议，具有内置拥塞控制的不可靠数据报的传输</span><br><span class="line">SOCK_PACKET = 10,  // 与网络驱动程序直接通信</span><br></pre></td></tr></table></figure>

<p>定义的协议（protocol）包含：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">    IPPROTO_IP = 0,         /* Dummy protocol for TCP       */</span><br><span class="line">    IPPROTO_ICMP = 1,       /* Internet Control Message Protocol    */</span><br><span class="line">    IPPROTO_IGMP = 2,       /* Internet Group Management Protocol   */</span><br><span class="line">    IPPROTO_IPIP = 4,       /* IPIP tunnels (older KA9Q tunnels use 94) */</span><br><span class="line">    IPPROTO_TCP = 6,        /* Transmission Control Protocol    */</span><br><span class="line">    IPPROTO_EGP = 8,        /* Exterior Gateway Protocol        */</span><br><span class="line">    IPPROTO_PUP = 12,       /* PUP protocol             */</span><br><span class="line">    IPPROTO_UDP = 17,       /* User Datagram Protocol       */</span><br><span class="line">    IPPROTO_IDP = 22,       /* XNS IDP protocol         */</span><br><span class="line">    IPPROTO_DCCP = 33,      /* Datagram Congestion Control Protocol */</span><br><span class="line">    IPPROTO_RSVP = 46,      /* RSVP protocol            */</span><br><span class="line">    IPPROTO_GRE = 47,       /* Cisco GRE tunnels (rfc 1701,1702)    */</span><br><span class="line">    IPPROTO_IPV6 = 41,      /* IPv6-in-IPv4 tunnelling      */</span><br><span class="line">    IPPROTO_ESP = 50,           /* Encapsulation Security Payload protocol */</span><br><span class="line">    IPPROTO_AH = 51,                /* Authentication Header protocol       */</span><br><span class="line">    IPPROTO_BEETPH = 94,            /* IP option pseudo header for BEET */</span><br><span class="line">    IPPROTO_PIM    = 103,       /* Protocol Independent Multicast   */</span><br><span class="line">    IPPROTO_COMP   = 108,           /* Compression Header protocol */</span><br><span class="line">    IPPROTO_SCTP   = 132,       /* Stream Control Transport Protocol    */</span><br><span class="line">    IPPROTO_UDPLITE = 136,      /* UDP-Lite (RFC 3828)          */</span><br><span class="line">    IPPROTO_RAW  = 255,     /* Raw IP packets           */</span><br><span class="line">    IPPROTO_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在Python中，主要的使用方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.socket([family[, type[, proto]]])</span><br></pre></td></tr></table></figure>

<p>family，套接字协议族，常见有：</p>
<ul>
<li>socket.AF_UNIX：只能够用于单一的Unix系统进程间通信</li>
<li>socket.AF_INET：服务器之间网络通信，IPv4</li>
<li>socket.AF_INET6：服务器之间网络通信，IPv6</li>
</ul>
<p>type: 套接字类型，包括：</p>
<ul>
<li>socket.SOCK_STREAM：流式socket，用于TCP</li>
<li>socket.SOCK_DGRAM：数据报式socket，用于UDP</li>
<li>socket.SOCK_SEQPACKET：可靠的连续数据包服务</li>
<li>socket.SOCK_RDM：可靠的UDP数据报</li>
<li>socket.SOCK_RAW：原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。</li>
</ul>
<p>protocol: </p>
<ul>
<li>默认：写 0 即可</li>
<li>CAN_RAW &#x2F; CAN_BCM：使用 AF_CAN 协议时</li>
</ul>
<p>连接方面：</p>
<ul>
<li>s.bind()：绑定地址到套接字，IPv4下，使用<code>(host, port)</code>绑定。</li>
<li>s.listen()：开启TCP监听。</li>
<li>s.accept()：等待连接（阻塞）。</li>
<li>s.connect()：主动连接服务器，IPv4下，使用<code>(host, port)</code>，如果连接失败，返回<code>socket.error</code>。</li>
<li>s.connect_ex()：主动连接服务器，出错时返回出错码。</li>
<li>s.close()：关闭套接字。</li>
<li>s.getpeername()：返回远程地址。</li>
<li>s.getsockname()：返回自己的地址。</li>
<li>s.settimeout(timeout)：设置超时时间，例如连接等待时间。</li>
<li>s.gettimeout()：获取超时时间。</li>
</ul>
<p>数据传输：</p>
<ul>
<li>s.recv()：接收TCP数据，可以指定最大接收量。</li>
<li>s.send()：发送TCP数据，返回发送的字节数。</li>
<li>s.sendall()：发送完整TCP数据，如果失败抛出异常。</li>
<li>s.recvfrom()：接收UDP数据，返回(data, address)。</li>
<li>s.sendto()：发送UDP数据，参数为(data, (ip, port))，返回发送的字节数。</li>
<li>s.setsockopt(level,optname,value)：设置套接字。</li>
<li>s.getsockopt(level,optname[.buflen])：获取设置。</li>
<li>s.fileno()：返回套接字的文件描述符。</li>
<li>s.setblocking(flag)：设置为非阻塞模式。</li>
<li>s.makefile()：创建套接字文件。</li>
</ul>
<p>TCP服务器例程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server = socket.socket()  # 默认 TCP</span><br><span class="line">serber.bind((&quot;127.0.0.1&quot;, 9001))</span><br><span class="line">server.listen(5)</span><br><span class="line">conn, address = server.accept()</span><br><span class="line">conn.send(&quot;&quot;.encode(&quot;utf8&quot;))</span><br><span class="line">data = conn.recv(1024)</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p>TCP客户端例程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client = socket.socket()</span><br><span class="line">client.connect((&quot;127.0.0.1&quot;, 9001))</span><br><span class="line">data = client.recv(1024)</span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<p>UDP服务器例程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) </span><br><span class="line">serber.bind((&quot;127.0.0.1&quot;, 9001))</span><br><span class="line">data, client = conn.recvfrom(1024)</span><br></pre></td></tr></table></figure>

<p>UDP客户端例程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">client.sendto(data, (&quot;127.0.0.1&quot;, 9001))</span><br></pre></td></tr></table></figure>

<h3 id="uWSGI"><a href="#uWSGI" class="headerlink" title="uWSGI"></a>uWSGI</h3><p>uWSGI 是Python搭建Web服务所用的中间件，是调和Web服务于Web应用直接的协议问题。</p>
<p>首先安装uWSGI：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install uwsgi</span><br><span class="line"># uwsgitop 用于监控数据</span><br><span class="line">pip install uwsgitop</span><br></pre></td></tr></table></figure>

<p>假设当前Nginx配置为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    include uwsgi_params;</span><br><span class="line">    uwsgi_pass 127.0.0.1:3031;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们启动一个uWSGI服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># --processes 添加更多的进程，用于并发</span><br><span class="line"># --threads 添加更多的线程，用于并发</span><br><span class="line"># --stats 使用 stats 子系统，可以执行监控任务 (uwsgitop)</span><br><span class="line"># --http-socket 启动地址，结合Nginx用</span><br><span class="line"># --wsgi-file 指定入口文件</span><br><span class="line"># --chdir 指定项目目录，如Django项目目录</span><br><span class="line">uwsgi --http-socket 127.0.0.1:3031 --chdir /home/foobar/myproject/ --wsgi-file myproject/wsgi.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191</span><br></pre></td></tr></table></figure>

<p>也可以写成配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1:3031</span><br><span class="line">chdir = /home/foobar/myproject/</span><br><span class="line">wsgi-file = myproject/wsgi.py</span><br><span class="line">processes = 4</span><br><span class="line">threads = 2</span><br><span class="line">stats = 127.0.0.1:9191</span><br></pre></td></tr></table></figure>

<p>接着执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi yourfile.ini</span><br></pre></td></tr></table></figure>

<p>如果不用Django框架，而是单独文件<code>server.py</code>，或是Flask框架：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># uWSGI Python 加载器将会搜索的默认函数 application </span><br><span class="line">def application(env, start_response):</span><br><span class="line">    start_response(&#x27;200 OK&#x27;, [(&#x27;Content-Type&#x27;,&#x27;text/html&#x27;)])</span><br><span class="line">    return [b&quot;Hello World&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>Python代码的执行由Python虚拟机（也叫解释器主循环）来控制。Python在设计之初就考虑到要在主循环中，同时只有一个线程在执行。虽然 Python 解释器中可以“运行”多个线程，但在任意时刻只有一个线程在解释器中运行。对Python虚拟机的访问由全局解释器锁(GIL)来控制，正是这个锁能保证同一时刻只有一个线程在运行。也就是说，<strong>尽管有了线程模块，Python几乎依然是单线程处理</strong>。</p>
<p>尽管如此，在IO密集型的多线程应用中，Python的多线程threading库表现却依然还行。但在并行计算型应用中，如果想真正实现多线程，就得在Python中可以使用多线程threading，并自行设计锁结构，或使用多进程multiprocessing，并在主进程设置消息队列，共享内存，管道等方式传递数据。</p>
<h3 id="threading-模块"><a href="#threading-模块" class="headerlink" title="threading 模块"></a>threading 模块</h3><p>创建线程，可以直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line">import time</span><br><span class="line">def sayhi(name):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&#x27;%s say hello&#x27; %name)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    t=Thread(target=sayhi,args=(&#x27;egon&#x27;,))</span><br><span class="line">    t.start()</span><br><span class="line">    print(&#x27;主线程&#x27;)</span><br><span class="line">    threading.enumerate() # 所有线程列表</span><br></pre></td></tr></table></figure>

<p>也可以通过子类继承后使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line">import time</span><br><span class="line">class Sayhi(Thread):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.name=name</span><br><span class="line">    def run(self):</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(&#x27;%s say hello&#x27; % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    t = Sayhi(&#x27;egon&#x27;)</span><br><span class="line">    t.start()</span><br><span class="line">    print(&#x27;主线程&#x27;)</span><br></pre></td></tr></table></figure>

<p>Thead 对象的常用方法有：</p>
<ul>
<li>isAlive()：是否运行</li>
<li>getName()：获取线程名称</li>
<li>setName()：设置线程名称</li>
<li>x.join()：当前线程等待x线程结束再继续执行。</li>
<li>setDaemon(True)：设置为守护线程</li>
</ul>
<p><strong>守护线性</strong>：如果设置一个线程为守护线程，就表示这个线程是不重要的，在进程退出的时候，不用等待这个线程退出。主线程只会等待所有非守护线程都结束后才退出。</p>
<p>threading 模块的常用方法有：</p>
<ul>
<li>threading.currentThread(): 返回当前的线程变量。</li>
<li>threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</li>
<li>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</li>
</ul>
<p>使用 <strong>同步锁</strong> 可以防止数据竞争问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">R = threading.Lock()</span><br><span class="line">R.acquire()</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">临界区</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">R.release()</span><br></pre></td></tr></table></figure>

<p>但是使用锁的时候，一定要解决好死锁的问题。解决方法可以参考《操作系统》相关章节。</p>
<p>线程间通信，可以使用消息队列，可以使用共享内存的方式进行通信。下面使用队列方式通信（注意互斥访问队列）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># JoinableQueue</span><br><span class="line"># 队列长度，多线程下不够准确</span><br><span class="line">Queue.qsize()</span><br><span class="line"># 队列判空</span><br><span class="line">Queue.empty()</span><br><span class="line"># 队列判满</span><br><span class="line">Queue.full()</span><br><span class="line"># 入队，是否阻塞</span><br><span class="line">Queue.put(item, block=True, timeout=None)</span><br><span class="line"># 入队，不阻塞</span><br><span class="line">Queue.put_nowait(item)</span><br><span class="line"># 出队，是否阻塞</span><br><span class="line">Queue.get(block=True, timeout=None)</span><br><span class="line"># 出队，不阻塞</span><br><span class="line">Queue.get_nowait()</span><br><span class="line"># 提示让出队列，提示join停止阻塞</span><br><span class="line">Queue.task_done()</span><br><span class="line"># 阻塞直到队列为空</span><br><span class="line">Queue.join()</span><br></pre></td></tr></table></figure>

<h3 id="multiprocessing-模块"><a href="#multiprocessing-模块" class="headerlink" title="multiprocessing 模块"></a>multiprocessing 模块</h3><p>多进程的创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line">def work():</span><br><span class="line">    print(&#x27;hello&#x27;,os.getpid())</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 会发现每一个进程都有不同的 PID</span><br><span class="line">    # 且进程的数据各自保留一份，互不相关</span><br><span class="line">    # 之间传递数据必须使用工具</span><br><span class="line">    p1=Process(target=work)</span><br><span class="line">    p2=Process(target=work)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    print(&#x27;主线程/主进程pid&#x27;,os.getpid())</span><br></pre></td></tr></table></figure>

<p>创建共享内存实现主进程与子进程通信：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import multiprocessing</span><br><span class="line"> </span><br><span class="line">def f(a):</span><br><span class="line">    a[0] = 5</span><br><span class="line"></span><br><span class="line"># 创建共享内存</span><br><span class="line">arr = multiprocessing.Array(&#x27;i&#x27;, range(10))</span><br><span class="line"># 子进程处理</span><br><span class="line">p = multiprocessing.Process(target=f, args=(arr,))</span><br><span class="line">p.start()</span><br><span class="line">p.join()</span><br><span class="line">print(arr[0])</span><br></pre></td></tr></table></figure>

<p>使用Manger通信，本质也是共享内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">def f(ls):</span><br><span class="line">    ls.append(&#x27;Hello&#x27;)</span><br><span class="line"></span><br><span class="line"># Manager 要在主进程创建</span><br><span class="line">server = multiprocessing.Manager()</span><br><span class="line"># 每调用一次list产生一个共享内存</span><br><span class="line"># 除了list外，也可以是其他形式，如队列、锁、字典、数组等</span><br><span class="line">ls = server.list()</span><br><span class="line"># ls = server.Queue()</span><br><span class="line"># 子进程处理</span><br><span class="line">proc = multiprocessing.Process(target=f, args=(ls,))</span><br><span class="line">proc.start()</span><br><span class="line">proc.join()</span><br><span class="line">print(ls)</span><br></pre></td></tr></table></figure>

<p>多进程间通过队列通信：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import multiprocessing</span><br><span class="line">from multiprocessing import Queue</span><br><span class="line"></span><br><span class="line">que = Queue(3)  # 队列容量 3</span><br><span class="line">que.put(&quot;msg 1&quot;)</span><br><span class="line">que.put(&quot;msg 2&quot;)</span><br><span class="line">que.full()  # False</span><br><span class="line">que.put(&quot;msg 3&quot;)</span><br><span class="line">que.full()  # True</span><br><span class="line">que.empty()  # False</span><br><span class="line"></span><br><span class="line">def fun(que):</span><br><span class="line">    d = que.get()</span><br><span class="line"></span><br><span class="line">p1 = multiprocessing.Process(target=fun, args=(que,))</span><br></pre></td></tr></table></figure>

<p>进程池：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import multiprocessing</span><br><span class="line">from multiprocessing import Pool</span><br><span class="line"></span><br><span class="line">def fun(arg):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">pool = Pool(3)  # 进程容量 3</span><br><span class="line">for i in range(10):</span><br><span class="line">    pool.apply_async(fun, (arg,))  # 添加任务</span><br><span class="line"></span><br><span class="line">pool.close()  # 关闭，不再接受新请求</span><br><span class="line">pool.join()   # 等待退出，必须在close之后</span><br></pre></td></tr></table></figure>

<h3 id="ctypes"><a href="#ctypes" class="headerlink" title="ctypes"></a>ctypes</h3><p>ctypes可以让Python直接调用任意的C动态库的导出函数，由于ctypes会在调用C函数前释放GIL，因此也可以实现多线程。</p>
<p>我们可以将写好的Task编译为C的动态库，例如<code>lib_task.so</code>或<code>lib_task.dll</code>，然后在Python中调用该库。打包动态库可以使用Visual Studio建立相关项目，Visual Studio就会自动生成一个DLL模板。或使用GCC创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">lib_task.h</span><br><span class="line">#ifndef LIB_TASK_H</span><br><span class="line">#define LIB_TASK_H</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot; C &quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// DLL 关键字 __declspec (dllexport)</span><br><span class="line">extern __declspec (dllexport) void Task(int arg);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">lib_task.c</span><br><span class="line">#include &quot;print.h&quot;</span><br><span class="line"></span><br><span class="line">// 在这里实现多线程</span><br><span class="line">void Task(int arg)</span><br><span class="line">&#123;</span><br><span class="line">    while(arg);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编辑DLL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gcc --share lib_task.c -o lib_task.dll</span><br><span class="line">from ctypes import *</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line"># lib_task.h 与 lib_task.dll 必须在这个目录下</span><br><span class="line"># 给DLL传递参数时，要将参数转化为C的类型</span><br><span class="line">lib = cdll.LoadLibrary(&quot;lib_task.dll&quot;)</span><br><span class="line">t = Thread(target=lib.Task, args=(1,))</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line">lib.Task()</span><br></pre></td></tr></table></figure>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池可以帮助我们自动调度线程，在需要多线程任务量巨大的情况下是非常好用的工具，省去我们考虑线程同步的问题，也节省了上下文切换的时间。</p>
<p>第三方线程池 threadpool：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pip install threadpool</span><br><span class="line">from threadpool import ThreadPool, makeRequests</span><br><span class="line"></span><br><span class="line"># 创建一个容纳4个线程的线程池</span><br><span class="line">pool = ThreadPool(4)</span><br><span class="line">requests = makeRequests(</span><br><span class="line">    some_callable,   # 多线程的任务</span><br><span class="line">    list_of_args,    # 参数</span><br><span class="line">    callback         # 回调函数，可空</span><br><span class="line">    )</span><br><span class="line">for req in requests:</span><br><span class="line">    pool.putRequest(req) </span><br><span class="line"># 等待线程池完成任务</span><br><span class="line">pool.wait()</span><br></pre></td></tr></table></figure>

<p>另外还有ThreadPoolExecutor，ProcessPoolExecutor，线程（进程）池也可以使用。</p>
<p>Executor提供了以下常用的方法：</p>
<p><code>submit(fn, *args,**kwargs)</code>：将fn函提交给池子；*args是传给fn函数的参数；**kwargs表示以关键字的形式为fn的参数。</p>
<p><code>map(func, *iterables, timeout=None, chunksize=1)</code>：类似于全局函数的map，只是该函数将会启动多个线程，以异步的方式立即对*iterables执行map处理，就是把for循环和submit结合在一起了。</p>
<p><code>shutdown(wait=True)</code>：关闭池子，wait&#x3D;True时等待池内所有任务执行完毕回收完资源后才继续；wait&#x3D;False时立即返回，并不会等待池内的任务执行完毕；但不管wait参数为何值，整个程序都会等到所有任务执行完毕才会清空池子，所以submit和map必须在shutdown之前执行。</p>
<p>程序将task函数submit之后，submit会返回一个Future对象，Future类主要用于获取线程或进程任务函数的返回值。Future中提供了一下方法：</p>
<p><code>cancel()</code>：取消Future代表的线程或者进程任务，如果任务正在执行，不可取消，返回False；否则任务取消，返回Ture。</p>
<p><code>cancelled()</code>：返回Future代表的任务是否被成功取消。</p>
<p><code>running()</code>：返回Future代表的任务是否增正在执行。</p>
<p><code>done()</code>：返回Future代表的任务是否已经结束。</p>
<p><code>result(timmeout=None)</code>：返回Future代表的任务的结果，如果任务没有完成，该方法将会阻塞当前线程，timeout指定阻塞多长时间。</p>
<p><code>exception()</code>：返回Future代表的任务的异常，如果没有异常，则返回None。</p>
<p><code>add_done_callback(fn)</code>：给Future代表的任务加一个’回调函数’，当该任务成功之后，执行这个fn函数。</p>
<p>创建线程池 ThreadPoolExecutor：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import time,threading</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">def f(n):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(f&quot;线程号 &#123;threading.get_ident()&#125;&quot;,n)</span><br><span class="line">    return n*n</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 创建线程池，线程数 5</span><br><span class="line">    t_pool = ThreadPoolExecutor(max_workers=5)</span><br><span class="line">    t_l = list()</span><br><span class="line">    for i in range(1,5):</span><br><span class="line">        t = t_pool.submit(f,i)</span><br><span class="line">        t_l.append(t)</span><br><span class="line">    t_pool.shutdown()</span><br><span class="line">    for i in t_l:</span><br><span class="line">        print(&#x27;===&#x27;,i.result())</span><br></pre></td></tr></table></figure>

<p>创建进程池 ProcessPoolExecutor：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import time,threading</span><br><span class="line">from concurrent.futures import ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">def callback_fun(x):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def f(n):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(f&quot;进程PID &#123;os.getpid()&#125;&quot;,n)</span><br><span class="line">    return n*n</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 创建进程池，进程数 5</span><br><span class="line">    p_pool = ProcessPoolExecutor(max_workers=5)</span><br><span class="line">    p_l = list()</span><br><span class="line">    for i in range(5):</span><br><span class="line">        t = p_pool.submit(f,i)</span><br><span class="line">        # 也可以设置回调函数，回调的参数由任务函数提供</span><br><span class="line">        # t.add_done_callback(callback_fun)</span><br><span class="line">        p_l.append(t)</span><br><span class="line">    # 也可以写成</span><br><span class="line">    # s = p_pool.map(f,range(1,5))   </span><br><span class="line">    p_pool.shutdown(wait = True)</span><br><span class="line">    for i in p_l:</span><br><span class="line">        print(&#x27;===&#x27;,i.result())</span><br></pre></td></tr></table></figure>

<p>multiprocessing 模块也提供了进程池：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import os,time</span><br><span class="line">from multiprocessing import Process,Pool</span><br><span class="line"></span><br><span class="line">def f(n):</span><br><span class="line">    print(f&quot;进程PID &#123;os.getpid()&#125;&quot;)</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    return n*n  # 返回值交给回调函数</span><br><span class="line"></span><br><span class="line">def cb_fun(n):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 创建工作进程</span><br><span class="line">    p = Pool(3)  </span><br><span class="line">    p_l = list()</span><br><span class="line">    for i in range(1,10):</span><br><span class="line">        re = p.apply(</span><br><span class="line">            f,              # 多线程工作函数</span><br><span class="line">            args=(i,),      # 传递的参数</span><br><span class="line">            callback=cb_fun # 回调函数</span><br><span class="line">        )</span><br><span class="line">        p_l.append(re)</span><br><span class="line">    print(p_l)</span><br><span class="line">    p_l.close()</span><br><span class="line">    p_l.join()</span><br></pre></td></tr></table></figure>

<h3 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器：可以节省内存空间，用每步生成的方式代替查表的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line"></span><br><span class="line">isinstance(&quot;abc&quot;, Iterable)  # 可迭代类型</span><br><span class="line"></span><br><span class="line">class Student(object):</span><br><span class="line">    names = []</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return StudentIterator(self)</span><br><span class="line"></span><br><span class="line">class StudentIterator(object):</span><br><span class="line">    def __init__(self, obj):</span><br><span class="line">        self.obj = obj</span><br><span class="line">        self.cnt = 0</span><br><span class="line">    def __next__(self):</span><br><span class="line">        if cnt &gt; len(self.obj.names):</span><br><span class="line">            raise StopIteration  # 告诉 for 已经迭代完毕</span><br><span class="line">        self.cnt += 1</span><br><span class="line">        return self.obj.names[0]</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"># 也可以合并为一个类</span><br><span class="line">class Fibonacci(object):</span><br><span class="line">    def __init__(self, all_num):</span><br><span class="line">        self.all_num = all_num</span><br><span class="line">        self.cnt = 0</span><br><span class="line">        self.a = 0</span><br><span class="line">        self.b = 1</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        if cnt &gt;= all_num:</span><br><span class="line">            raise StopIteration  # 告诉 for 已经迭代完毕</span><br><span class="line">        self.cnt += 1</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        return self.b</span><br><span class="line">    </span><br><span class="line">fib = Fibonacci(10)</span><br><span class="line">for x in fib:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>

<p>对于如下代码，执行步骤为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for item in obj: ...</span><br></pre></td></tr></table></figure>

<ol>
<li>判断obj是否是迭代类型（是否有<code>__iter__</code>方法）；</li>
<li>调用<code>__iter__</code>方法得到迭代器，获取<code>__iter__</code>的返回值（返回了一个迭代器）。</li>
<li>每for一次，调用一次<code>__next__</code></li>
</ol>
<p>迭代器实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range(10)   # 直接生成数据</span><br><span class="line">xrange(10)  # 底层为迭代器，可以节省内存</span><br></pre></td></tr></table></figure>

<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器是一种特殊的迭代器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 普通方式创建数组</span><br><span class="line">nums = [x for x in range(10)]</span><br><span class="line"># 生成器方式，节省空间</span><br><span class="line">nums = (x for x in range(10))</span><br><span class="line"># 迭代生成器</span><br><span class="line">for x in nums:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>

<p>将函数变为生成器：只要函数中包含<code>yield</code>即可，此时调用函数，得到一个生成器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def fib(n):</span><br><span class="line">    a, b = 0, 1</span><br><span class="line">    cnt = 0</span><br><span class="line">    while cnt &lt; n:</span><br><span class="line">        yield a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        cnt += 1</span><br><span class="line">    # return 可有可无</span><br><span class="line">    return &quot;over&quot;</span><br><span class="line"></span><br><span class="line">obj = fib(10)  # 得到生成器</span><br><span class="line">for x in obj:</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line">obj2 = fib(4)</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        ret = next(obj2)</span><br><span class="line">    except Except as ex:</span><br><span class="line">        print(ex.value)  # 此处存储 fib 的 return</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<p>通过<code>send</code>方法启动生成器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def fib(n):</span><br><span class="line">    a, b = 0, 1</span><br><span class="line">    cnt = 0</span><br><span class="line">    while cnt &lt; n:</span><br><span class="line">        ret = yield a  # 此处 ret 接收 send 方法给的值</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        cnt += 1</span><br><span class="line"></span><br><span class="line">obj = fib(10)</span><br><span class="line">ret = next(obj)       # 启动生成器 得到第一个元素 给 ret</span><br><span class="line">ret = obj.send(&quot;xx&quot;)  # 给 生成器 中的 ret 传递值 xx</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line"># 注：send 必须在 next 之后执行；要么在next之前执行，传递 None</span><br></pre></td></tr></table></figure>

<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p><code>greenlet</code> 模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from greenlet import greenlet</span><br><span class="line"></span><br><span class="line">def fun1():</span><br><span class="line">    ...</span><br><span class="line">    gr2.switch()</span><br><span class="line">    ...</span><br><span class="line">    pass</span><br><span class="line">def fun2():</span><br><span class="line">    ...</span><br><span class="line">    gr1.switch()</span><br><span class="line">    ...</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">g1 = greenlet(fun1)</span><br><span class="line">g2 = greenlet(fun2)</span><br><span class="line"></span><br><span class="line">g1.switch()  # 切入 fun1 运行</span><br></pre></td></tr></table></figure>

<p><code>gevent</code> 模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line"></span><br><span class="line">def fun(n):</span><br><span class="line">    for i in range(n):</span><br><span class="line">        print(gevent.getcurrent(), i)</span><br><span class="line">        gevent.sleep(0.5)  # gevent 内部必须使用自己的延时等待</span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(fun, 5)  # 创建协程 函数 fun 参数 5</span><br><span class="line">g2 = gevent.spawn(fun, 5)</span><br><span class="line">g3 = gevent.spawn(fun, 5)</span><br><span class="line"></span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br></pre></td></tr></table></figure>

<p>给代码打补丁升级：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line">from gevent import monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()  # 打补丁，临时改写代码</span><br><span class="line"></span><br><span class="line">def fun(n):</span><br><span class="line">    for i in range(n):</span><br><span class="line">        print(gevent.getcurrent(), i)</span><br><span class="line">        time.sleep(0.5)  # 有了补丁，可以不必更改延时函数</span><br><span class="line"></span><br><span class="line"># 写法与上面的等效</span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(fun, 5),</span><br><span class="line">    gevent.spawn(fun, 5)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h2 id="XML-与-JSON"><a href="#XML-与-JSON" class="headerlink" title="XML 与 JSON"></a>XML 与 JSON</h2><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>XML 指可扩展标记语言（eXtensible Markup Language），形式同HTML，是一种用于标记电子文件使其具有结构性的标记语言。XML也可以用于数据以文本格式存储下来。格式如下（DOM）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;collection shelf=&quot;New Arrivals&quot;&gt;</span><br><span class="line">&lt;movie title=&quot;Enemy Behind&quot;&gt;</span><br><span class="line">   &lt;type&gt;War, Thriller&lt;/type&gt;</span><br><span class="line">   &lt;format&gt;DVD&lt;/format&gt;</span><br><span class="line">   &lt;year&gt;2003&lt;/year&gt;</span><br><span class="line">   &lt;rating&gt;PG&lt;/rating&gt;</span><br><span class="line">   &lt;stars&gt;10&lt;/stars&gt;</span><br><span class="line">   &lt;description&gt;Talk about a US-Japan war&lt;/description&gt;</span><br><span class="line">&lt;/movie&gt;</span><br><span class="line">&lt;movie title=&quot;Transformers&quot;&gt;</span><br><span class="line">   &lt;type&gt;Anime, Science Fiction&lt;/type&gt;</span><br><span class="line">   &lt;format&gt;DVD&lt;/format&gt;</span><br><span class="line">   &lt;year&gt;1989&lt;/year&gt;</span><br><span class="line">   &lt;rating&gt;R&lt;/rating&gt;</span><br><span class="line">   &lt;stars&gt;8&lt;/stars&gt;</span><br><span class="line">   &lt;description&gt;A schientific fiction&lt;/description&gt;</span><br><span class="line">&lt;/movie&gt;</span><br><span class="line">   &lt;movie title=&quot;Trigun&quot;&gt;</span><br><span class="line">   &lt;type&gt;Anime, Action&lt;/type&gt;</span><br><span class="line">   &lt;format&gt;DVD&lt;/format&gt;</span><br><span class="line">   &lt;episodes&gt;4&lt;/episodes&gt;</span><br><span class="line">   &lt;rating&gt;PG&lt;/rating&gt;</span><br><span class="line">   &lt;stars&gt;10&lt;/stars&gt;</span><br><span class="line">   &lt;description&gt;Vash the Stampede!&lt;/description&gt;</span><br><span class="line">&lt;/movie&gt;</span><br><span class="line">&lt;movie title=&quot;Ishtar&quot;&gt;</span><br><span class="line">   &lt;type&gt;Comedy&lt;/type&gt;</span><br><span class="line">   &lt;format&gt;VHS&lt;/format&gt;</span><br><span class="line">   &lt;rating&gt;PG&lt;/rating&gt;</span><br><span class="line">   &lt;stars&gt;2&lt;/stars&gt;</span><br><span class="line">   &lt;description&gt;Viewable boredom&lt;/description&gt;</span><br><span class="line">&lt;/movie&gt;</span><br><span class="line">&lt;/collection&gt;</span><br></pre></td></tr></table></figure>

<p>解析 XML 可以使用 SAX 模块，SAX 模块用事件驱动模型，通过在解析 XML 的过程中触发一个个的事件并调用用户定义的回调函数来处理 XML 文件。SAX 模块非常适用于对大型文件进行处理，且只需要文件部分信息时使用。</p>
<p>通过使用ContentHandler类读取数据。ContentHandler的方法有：</p>
<ul>
<li>startDocument()：文档启动时调用。</li>
<li>endDocument()：到达结尾时调用。</li>
<li>startElement(name, attrs)：遇到开始标签&lt;..&gt;调用。</li>
<li>endElement(name)：遇到结束标签&lt;&#x2F;..&gt;调用。</li>
<li>characters(content)：分情况看，有<ul>
<li>从行开始，遇到标签之前，若存在字符，则content的值为这些字符串。</li>
<li>从一个标签，遇到下一个标签之前，若存在字符，则content的值为这些字符串。</li>
<li>从一个标签，遇到行结束符之前，若存在字符，则content的值为这些字符串。</li>
<li>标签可以是开始标签，也可以是结束标签。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import xml.sax</span><br><span class="line"></span><br><span class="line">class MovieHandler( xml.sax.ContentHandler ):</span><br><span class="line">    def __init__(self):  # 此处定义对象属性</span><br><span class="line">        pass</span><br><span class="line">    # 元素开始调用</span><br><span class="line">    def startElement(self, tag, attributes):</span><br><span class="line">        pass</span><br><span class="line">    # 元素结束调用</span><br><span class="line">    def endElement(self, tag):</span><br><span class="line">        pass</span><br><span class="line">    # 读取字符时调用</span><br><span class="line">    def characters(self, content):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"># 创建XML阅读器</span><br><span class="line">parser = xml.sax.make_parser()</span><br><span class="line"># 关闭命名空间</span><br><span class="line">parser.setFeature(xml.sax.handler.feature_namespaces, 0)</span><br><span class="line"># 创建对象</span><br><span class="line">Handler = MovieHandler()</span><br><span class="line"># 设置XML阅读器</span><br><span class="line">parser.setContentHandler(Handler)</span><br><span class="line"># 开始解析</span><br><span class="line">parser.parse(&quot;movies.xml&quot;)</span><br></pre></td></tr></table></figure>

<p>如果解析的文件不大，且需要文件的全部信息，可以使用DOM解析器。这个解析器可以一次性将整个文档读入内存，且可读可写到文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from xml.dom.minidom import parse</span><br><span class="line">import xml.dom.minidom</span><br><span class="line"></span><br><span class="line"># 使用minidom解析器打开 XML 文档</span><br><span class="line">DOMTree = xml.dom.minidom.parse(&quot;movies.xml&quot;)</span><br><span class="line">collection = DOMTree.documentElement</span><br><span class="line">if collection.hasAttribute(&quot;shelf&quot;):</span><br><span class="line">   print (f&quot;Root element : &#123;collection.getAttribute(&#x27;shelf&#x27;)&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 在集合中获取所有电影</span><br><span class="line">movies = collection.getElementsByTagName(&quot;movie&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><p>JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式，适合于网络间传输数据，如前后端使用Ajax传输，则偏向于传输Json。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    &#x27;no&#x27; : 1,</span><br><span class="line">    &#x27;name&#x27; : &#x27;Runoob&#x27;,</span><br><span class="line">    &#x27;url&#x27; : &#x27;http://www.runoob.com&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Python 字典类型转换为 JSON 对象</span><br><span class="line">json_str = json.dumps(data)</span><br><span class="line"># 将 JSON 对象转换为 Python 字典</span><br><span class="line">data = json.loads(json_str)</span><br></pre></td></tr></table></figure>

<h2 id="Python-技巧"><a href="#Python-技巧" class="headerlink" title="Python 技巧"></a>Python 技巧</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><ol>
<li>使用元组存储数据，节省空间。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 方式 1</span><br><span class="line">Name, Age, Gender, Email = 1, 2, 3, 4</span><br><span class="line">student = (&#x27;mike&#x27;, 18, &#x27;male&#x27;, &#x27;123@qq.com&#x27;)</span><br><span class="line">name = student[Name]</span><br><span class="line"></span><br><span class="line"># 方式 2</span><br><span class="line">from collections import namedtuple</span><br><span class="line">Student = namedtuple(&#x27;Student&#x27;, [&#x27;NName&#x27;, &#x27;Age&#x27;, &#x27;Gender&#x27;, &#x27;Email&#x27;])</span><br><span class="line">student = Student(&#x27;jim&#x27;, 16, ...)</span><br><span class="line">name = student.name</span><br></pre></td></tr></table></figure>

<ol>
<li>统计序列中的元素出现频率</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 产生数据</span><br><span class="line">from random import randint</span><br><span class="line">data = [randint(0, 20) for _ in range(30)]</span><br><span class="line"></span><br><span class="line"># 方式 1: 产生结果为字典 </span><br><span class="line">c = dict.fromkeys(data, 0)</span><br><span class="line">for x in data:</span><br><span class="line">    c[x] += 1</span><br><span class="line"></span><br><span class="line"># 方式 2: 结果也是字典，但是还有其他统计信息</span><br><span class="line">from collections import Counter</span><br><span class="line">c2 = Counter(data)</span><br><span class="line">c2.most_common(3) # 频数最大的 3 个元素</span><br><span class="line"></span><br><span class="line"># 例如统计词频</span><br><span class="line">c3 = Counter(re.split(&quot;\W+&quot;, filename))</span><br></pre></td></tr></table></figure>

<ol>
<li>根据字典中值的大小，排序字典序</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 产生数据</span><br><span class="line">from random import randint</span><br><span class="line">d = &#123;x: randint(60, 100) for x in &#x27;xyzabc&#x27;&#125;</span><br><span class="line"></span><br><span class="line"># 方式 1</span><br><span class="line">sorted(zip(d.values(), d.keys()))</span><br><span class="line"></span><br><span class="line"># 方式 2</span><br><span class="line">sorted(d.items(), key=lambda x: x[1])</span><br></pre></td></tr></table></figure>

<ol>
<li>找到多个字典的公共键</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 产生数据</span><br><span class="line">from random import randint, sample</span><br><span class="line">s1 = &#123;x: randint(1, 4) for x in sample(&#x27;abcdefg&#x27;, randint(3, 6))&#125;</span><br><span class="line">s2 = &#123;x: randint(1, 4) for x in sample(&#x27;abcdefg&#x27;, randint(3, 6))&#125;</span><br><span class="line">s3 = &#123;x: randint(1, 4) for x in sample(&#x27;abcdefg&#x27;, randint(3, 6))&#125;</span><br><span class="line"></span><br><span class="line"># 方式 1</span><br><span class="line">s1.keys() &amp; s2.keys() &amp; s3.keys()</span><br><span class="line"></span><br><span class="line"># 方式 2</span><br><span class="line">from functools import reduce</span><br><span class="line">reduce(lambda a, b: a &amp; b, map(dict.keys, [s1, s2, s3]))</span><br></pre></td></tr></table></figure>

<ol>
<li>让字典保持有序</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 方式 1: 使用有序字典</span><br><span class="line">from collections import OrderedDict</span><br><span class="line">d = OrderedDict()</span><br><span class="line">d[&#x27;a&#x27;] = (1, 10)</span><br><span class="line">d[&#x27;b&#x27;] = (2, 16)</span><br><span class="line">d[&#x27;c&#x27;] = (3, 20)</span><br><span class="line"># 按照输入的顺序存储</span><br></pre></td></tr></table></figure>

<ol>
<li>实现历史记录功能</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 方式 1: 使用双端队列</span><br><span class="line">from collections import deque</span><br><span class="line">q = deque([], 5) # 初始值 容量</span><br><span class="line">q.append(1)</span><br><span class="line"></span><br><span class="line">import pickle # python 对象持久化</span><br><span class="line">pickle.dump(q, open(&quot;filename&quot;, &quot;w&quot;))</span><br><span class="line">q = pickle.load(open(&quot;filename&quot;))</span><br></pre></td></tr></table></figure>

<ol>
<li>切片操作</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d[1:3]</span><br><span class="line"></span><br><span class="line"># 创建可切片的迭代器</span><br><span class="line">from itertools import islice</span><br><span class="line">for line in islice(d, 1, 3):</span><br><span class="line">    print(line)</span><br></pre></td></tr></table></figure>

<ol>
<li>同时迭代多个对象</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 产生数据</span><br><span class="line">from random import randint</span><br><span class="line">a = [randint(60, 100) for _ in range(40)]</span><br><span class="line">b = [randint(60, 100) for _ in range(40)]</span><br><span class="line"></span><br><span class="line"># 方式 1: 采用索引</span><br><span class="line">for i in range(len(a)):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 方式 2: 采用zip</span><br><span class="line">for x, y in zip(a, b):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 方式 3: 串行连接多个迭代对象</span><br><span class="line">from itertools import chain</span><br><span class="line">for x in chain(a, b):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<ol>
<li>修改列表的元素</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 产生数据</span><br><span class="line">from random import randint</span><br><span class="line">a = [x: randint(60, 100) for _ in range(40)]</span><br><span class="line"></span><br><span class="line"># 方式 1: 有Bug</span><br><span class="line">for item in d:</span><br><span class="line">    i = d.index(item)</span><br><span class="line">    d[i] += 1</span><br><span class="line"></span><br><span class="line"># 方式 2: </span><br><span class="line">for i, item in enumerate(d):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><ol>
<li>拆分字符串</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 产生数据</span><br><span class="line">s = &#x27;ab;cd|efg|hi,jkl|mn\topq;;rs t,uvw\txyz&#x27;</span><br><span class="line"></span><br><span class="line"># 方式 1:</span><br><span class="line">s.split() # 默认为 \t 空格</span><br><span class="line">s.split(&#x27;;&#x27;)</span><br><span class="line"></span><br><span class="line"># 方式 2: 正则</span><br><span class="line">import re</span><br><span class="line">re.split(&#x27;[,;\t|]+&#x27;, s)</span><br></pre></td></tr></table></figure>

<ol>
<li>是否有某一前缀、后缀</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 产生数据</span><br><span class="line">s = &#x27;www.baidu.com&#x27;</span><br><span class="line"></span><br><span class="line"># 方式 1:</span><br><span class="line">s.startwith(&quot;www&quot;)</span><br><span class="line">s.endwith((&quot;com&quot;, &quot;org&quot;))  # 只能是元组</span><br></pre></td></tr></table></figure>

<ol>
<li>调整字符串格式</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 产生数据</span><br><span class="line">s = &#x27;2016-05-01&#x27; # 改为 05/01/2016</span><br><span class="line"></span><br><span class="line"># 方式 1:</span><br><span class="line">import re</span><br><span class="line">re.sub(r&#x27;(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)&#x27;, r&#x27;\2/\1/\3&#x27;, s)</span><br><span class="line">re.sub(r&#x27;(?P&lt;year&gt;\d&#123;4&#125;)-(?P&lt;month&gt;\d&#123;2&#125;)-(?P&lt;day&gt;\d&#123;2&#125;)&#x27;, r&#x27;\g&lt;month&gt;/\g&lt;day&gt;/\g&lt;year&gt;&#x27;, s)</span><br></pre></td></tr></table></figure>

<ol>
<li>拼接多个字符串</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 产生数据</span><br><span class="line">s1 = &#x27;12345&#x27;</span><br><span class="line">s2 = &#x27;67890&#x27;</span><br><span class="line"></span><br><span class="line"># 方式 1:</span><br><span class="line">&#x27;;&#x27;.join([s1, s2])</span><br></pre></td></tr></table></figure>

<ol>
<li>字符串对齐</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 产生数据</span><br><span class="line">d = &#123;&#x27;name&#x27;: &#x27;mike&#x27;, &#x27;age&#x27;: 19&#125;</span><br><span class="line"></span><br><span class="line"># 方式 1:</span><br><span class="line">d[&#x27;name&#x27;].ljust(10)</span><br><span class="line">d[&#x27;name&#x27;].rjust(10, &#x27;.&#x27;)</span><br><span class="line">d[&#x27;name&#x27;].center(10)</span><br><span class="line"></span><br><span class="line"># 方式 2:</span><br><span class="line">format(s, &#x27;&lt;20&#x27;)  </span><br><span class="line">format(s, &#x27;&gt;20&#x27;)</span><br><span class="line">format(s, &#x27;^20&#x27;)</span><br></pre></td></tr></table></figure>

<ol>
<li>去除不需要的字符</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 产生数据</span><br><span class="line">s1 = &#x27;   abc  123    &#x27;</span><br><span class="line"></span><br><span class="line"># 方式 1</span><br><span class="line">s.strip(&#x27; &#x27;)  # 去掉两端字符，默认为 空格</span><br><span class="line">s.lstrip()</span><br><span class="line">s.rstrip()</span><br><span class="line"></span><br><span class="line"># 方法 2</span><br><span class="line">s = s[:3] + s[4:]</span><br><span class="line"></span><br><span class="line"># 方法 3</span><br><span class="line">s.replace(&#x27;\t&#x27;, &#x27;&#x27;)</span><br><span class="line"></span><br><span class="line"># 方法 4</span><br><span class="line">re.sub(r&#x27;[\t\r]&#x27;, &#x27;&#x27;, s)</span><br><span class="line"></span><br><span class="line"># 方法 5</span><br><span class="line">import string</span><br><span class="line">s.translate(string.maketrans(&#x27;abcxyz&#x27;, &#x27;xyzabc&#x27;))</span><br><span class="line">s.translate(None, &#x27; &#x27;) # 删除字符</span><br></pre></td></tr></table></figure>

<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ol>
<li>处理二进制文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 产生数据</span><br><span class="line">f = open(&quot;filename&quot;, &quot;rb&quot;)</span><br><span class="line"></span><br><span class="line"># 方式 1</span><br><span class="line">import struct</span><br><span class="line"># 模式：h-short i-int</span><br><span class="line">struct.unpack(&#x27;h&#x27;, &#x27;\x01\x02&#x27;)   # 小端</span><br><span class="line">struct.unpack(&#x27;&gt;h&#x27;, &#x27;\x01\x02&#x27;)  # 大端</span><br><span class="line">import array</span><br><span class="line">buf = array.array(&#x27;h&#x27;, (0 for _ in range(length)))</span><br></pre></td></tr></table></figure>

<ol>
<li>文件缓冲</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 全缓冲</span><br><span class="line">f = open(&#x27;&#x27;, &#x27;w&#x27;, buffering=2048)  # 缓冲区默认 4096 大小</span><br><span class="line"># 行缓冲</span><br><span class="line">f = open(&#x27;&#x27;, &#x27;w&#x27;, buffering=1)   </span><br><span class="line"># 无缓冲</span><br><span class="line">f = open(&#x27;&#x27;, &#x27;w&#x27;, buffering=0) </span><br></pre></td></tr></table></figure>

<ol>
<li>将文件映射到内存</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f = open(&#x27;&#x27;, &#x27;r+b&#x27;)</span><br><span class="line">  # 映射文件描述符到内存，0表示映射区域为文件全文</span><br><span class="line">m = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_WRITE)</span><br><span class="line">m = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_WRITE, offset=mmap.PAGESIZE * 4)</span><br><span class="line">m[1:10]</span><br><span class="line">m[3] = &#x27;0x30&#x27;</span><br></pre></td></tr></table></figure>

<ol>
<li>文件状态</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 系统调用</span><br><span class="line">import os</span><br><span class="line">os.stat(path)</span><br><span class="line">os.lstat(path)  # 不跟随符号链接</span><br><span class="line">os.fstat(open(&quot;&quot;, &quot;&quot;))</span><br><span class="line"></span><br><span class="line"># 包括: 文件类型，文件权限，时间（访问，修改，创建），文件大小</span><br><span class="line"></span><br><span class="line">os.path.isdir()</span><br><span class="line">os.path.isfile()</span><br><span class="line">os.path.islink()</span><br><span class="line">os.path.getatime()</span><br><span class="line">os.path.getsize()</span><br></pre></td></tr></table></figure>

<ol>
<li>使用临时文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from tempfile import TemporaryFile, NamedTemporaryFile</span><br><span class="line">f = TemporaryFile()</span><br><span class="line">f.write()</span><br></pre></td></tr></table></figure>

<ol>
<li>读写 CSV</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line">rf = open(&#x27;&#x27;, &#x27;rb&#x27;)  # 一定是二进制打开</span><br><span class="line">reader = csv.reader(rf)</span><br><span class="line">head = reader.next()</span><br><span class="line">for row in reader:</span><br><span class="line">    print(row[0], row[1])</span><br><span class="line">writer = csv.writer(wf)</span><br><span class="line">writer.writerow()</span><br><span class="line">writer.flush()</span><br></pre></td></tr></table></figure>

<ol>
<li>读写 JSON</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">json.loads()</span><br><span class="line">json.dumps()</span><br></pre></td></tr></table></figure>

<ol>
<li>读写 XML</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from xml.etree.ElementTree import parse</span><br><span class="line">f = open()</span><br><span class="line">et = parse(f)</span><br><span class="line">root = et.getroot()</span><br><span class="line">root.tag</span><br><span class="line">root.attrib</span><br><span class="line">root.text</span><br><span class="line">for child in root:</span><br><span class="line">    print(child.get(&#x27;name&#x27;))</span><br><span class="line"># 在子元素中找</span><br><span class="line">root.find()</span><br><span class="line">root.findall()</span><br><span class="line"># 在所有子孙中找</span><br><span class="line">root.iter()</span><br><span class="line">root.findall(&quot;.//node&quot;)  # 这里使用 XPATH 表示</span><br></pre></td></tr></table></figure>

<ol>
<li>读写 Excel</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import xlrd xlwt</span><br><span class="line">book = xlrd.open_workbook()</span><br><span class="line">sheet = book.sheets()[0]</span><br><span class="line">sheet.nrows</span><br><span class="line">sheet.ncols</span><br><span class="line">cell = sheet.cell(3, 5)</span><br><span class="line">cell.ctype</span><br><span class="line">sheet.row(1)</span><br></pre></td></tr></table></figure>

<h3 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h3><ol>
<li>创建大量实例并节省内存</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Player(object):</span><br><span class="line">    # __slots__ 限制有哪些属性，关闭动态字典属性</span><br><span class="line">    __slots__ = [&#x27;uid&#x27;, &#x27;name&#x27;, &#x27;stat&#x27;, &#x27;level&#x27;]</span><br><span class="line">    def __init__(self, uid, name, status=0, level=1):</span><br><span class="line">        self.uid = uid</span><br><span class="line">        self.name = name</span><br><span class="line">        self.stat = status</span><br><span class="line">        self.level = level</span><br></pre></td></tr></table></figure>

<ol>
<li>使用上下文管理</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Client(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    def start(self):</span><br><span class="line">        pass</span><br><span class="line">    def cleanup(self):</span><br><span class="line">        pass</span><br><span class="line">    def __enter__(self):</span><br><span class="line">        return self</span><br><span class="line">    def __exit__(self, exc_type, exc_val, exc_tb):  # 后面参数为异常</span><br><span class="line">        pass</span><br><span class="line">        return True          # 不向上抛出异常</span><br><span class="line">        return False / None  # 向上抛出异常</span><br><span class="line"></span><br><span class="line">with Client() as c:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<ol>
<li>创建可管理的对象属性</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Circle(object):</span><br><span class="line">    radius = 0</span><br><span class="line">    def getRadius(self):</span><br><span class="line">        return self.radius</span><br><span class="line">    def setRadius(self, r):</span><br><span class="line">        if not isinstance(r, (int, float)):</span><br><span class="line">            raise ValueError(&#x27;wrong type.&#x27;)</span><br><span class="line">        self.radius = float(r)</span><br><span class="line">    R = property(getRadius, setRadius) </span><br><span class="line">c = Circle()</span><br><span class="line">c.R = 1</span><br><span class="line">print(c.R)</span><br></pre></td></tr></table></figure>

<ol>
<li>比较操作</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Circle(object):</span><br><span class="line">    radius = 0</span><br><span class="line">    def getRadius(self):</span><br><span class="line">        return self.radius</span><br><span class="line">    def setRadius(self, r):</span><br><span class="line">        if not isinstance(r, (int, float)):</span><br><span class="line">            raise ValueError(&#x27;wrong type.&#x27;)</span><br><span class="line">        self.radius = float(r)</span><br><span class="line">    def __lt__(self, obj):</span><br><span class="line">        pass</span><br><span class="line">    def __ge__(self, obj):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

<ol>
<li>类型检查</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Attr(object):</span><br><span class="line">    def __init__(self, name, type_):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.type_ = type_</span><br><span class="line">    def __get__(self, instance, clazz):</span><br><span class="line">        return instance.__dict__[self.name]</span><br><span class="line">    def __set__(self, instance, value):</span><br><span class="line">        # 此处插入类型检查</span><br><span class="line">        if not isinstance(value, self.type_):</span><br><span class="line">            raise TypeError(f&#x27;expected an &#123;self.type_&#125;&#x27;)</span><br><span class="line">        instance.__dict__[self.name] = value</span><br><span class="line">    def __delete__(self, instance):</span><br><span class="line">        del instance.__dict__[self.name]</span><br><span class="line">class Person(object):</span><br><span class="line">    name = Attr(&#x27;name&#x27;, str)</span><br><span class="line">    age = Attr(&#x27;name&#x27;, int)</span><br></pre></td></tr></table></figure>

<ol>
<li>循环引用垃圾回收问题</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用弱引用</span><br><span class="line">import wearref</span><br><span class="line">a = A()</span><br><span class="line">a_wref = weakref.ref(a)</span><br></pre></td></tr></table></figure>

<ol>
<li>通过字符串调用实例方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 方法 1:</span><br><span class="line">s = Person()</span><br><span class="line">fun = getattr(s, &#x27;getName&#x27;, None)  # 第三个参数为找不到时的默认值</span><br><span class="line">if fun: fun()</span><br><span class="line"></span><br><span class="line"># 方法 2:</span><br><span class="line">from operator import methodcaller</span><br><span class="line">methodcaller(&#x27;findPerson&#x27;, &#x27;name&#x27;, age)(s)</span><br></pre></td></tr></table></figure>

<h3 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h3>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"># Python</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/02/09/Python/PythonGUI/" rel="prev" title="Python GUI">
                  <i class="fa fa-angle-left"></i> Python GUI
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/02/11/%E8%BF%90%E7%BB%B4/Windows/" rel="next" title="Windows">
                  Windows <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Peng</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  

  <a href="https://github.com/withz" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.12/pdfobject.min.js","integrity":"sha256-g2xji1rlE3KsGVClvuxTbcR0Kn2+wtQADSff2Tbb4zA="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://withz.github.io/2020/02/09/Python/Python/"}</script>
  <script src="/js/third-party/quicklink.js"></script>

</body>
</html>
